(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[727],{79443:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});const o=(0,n(67294).createContext)(void 0)},80944:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var o=n(67294),r=n(79443);const i=function(){const e=(0,o.useContext)(r.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e}},36438:(e,t,n)=>{"use strict";n.d(t,{p:()=>l,Z:()=>d});var o=n(67294),r=n(80944);const i=JSON.parse('{"rust":{"remove-query":"let removed_ids = col_tx\\n    .find_with_args(\\"color == $args.color\\", json!({\\"color\\": \\"yellow\\"}))\\n    .remove()\\n    .unwrap();\\n\\n","evict":"let evicted_ids = collection\\n    .find_with_args(\\"$args.color == color\\", json!({\\"color\\": \\"red\\"}))\\n    .sort(vec![sort_param])\\n    .evict()\\n    .unwrap();\\n\\n","sync-basic":"ditto.start_sync()?;\\n\\n","datamodel":"let store = ditto.store();\\nlet collection = store.collection(\\"people\\").unwrap();\\n\\n","upsert-id":"let doc_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet person = json!({ // Person implements serde::Serialize\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(person).unwrap();\\n\\n","array-to-map":"collection\\n    .find_by_id(doc_id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            let friends: DittoRegister = doc.get(\\"friends\\").unwrap();\\n            let mut map = HashMap::new();\\n            let array = friends.value.as_array().unwrap();\\n\\n            for name in array {\\n                let id = Uuid::new_v4().to_string();\\n                let friend = json!({\\n                    \\"name\\": name,\\n                    \\"id\\": id\\n                });\\n                map.insert(id, friend);\\n            }\\n\\n            doc.set(\\"friendsMap\\", map).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","upsert":"let person = json!({\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\nlet collection = ditto.store().collection(\\"people\\").unwrap();\\nlet id = collection.upsert(person).unwrap();\\n\\n","remove-id":"collection.find_by_id(id).remove().unwrap();\\n\\n","upsert-composite-primary-key":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet complex_id = PersonId {\\n    user_id: \\"456abc\\".to_string(),\\n    work_id: 789,\\n};\\nlet doc_id = DocumentId::new(&serde_json::json!(complex_id)).unwrap();\\nlet doc = json!({\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(doc).unwrap();\\n\\n","upsert-datatypes":"collection\\n    .upsert(json!({\\n      \\"boolean\\": true,\\n      \\"string\\": \\"Hello World\\",\\n      \\"number\\": 10,\\n      \\"map\\": {\\n        \\"key\\": \\"value\\"\\n      },\\n      \\"array\\": [1,2,3],\\n      \\"null\\": null,\\n    }))\\n    .unwrap();\\n\\n","upsert-default-data":"let default_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet data = json!({ // Person implements serde::Serialize\\n    \\"_id\\": default_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection\\n    .upsert_with_strategy(data, WriteStrategy::InsertDefaultIfAbsent)\\n    .unwrap();\\n\\n","attachment":"let store = ditto.store();\\nlet collection = store.collection(\\"foo\\")?;\\nlet attachment_file_path = images_dir.join(\\"image.png\\");\\nlet mut metadata = HashMap::new();\\nmetadata.insert(\\"some\\".to_owned(), \\"string\\".to_owned());\\nlet attachment =\\n    collection.new_attachment(attachment_file_path.to_str().unwrap(), metadata)?;\\nlet doc_id = DocumentId::new(&\\"123abc\\".to_string())?;\\nlet content = json!({\\"_id\\": doc_id, \\"some\\": \\"string\\", \\"my_attachment\\": attachment});\\nlet _ = collection.upsert(content)?;\\n// Later or on another peer ...\\nlet doc = collection.find_by_id(doc_id).exec()?;\\nlet attachment_token = doc.get::<DittoAttachmentToken>(\\"my_attachment\\")?;\\nlet (tx, rx) = channel();\\nlet m_tx = std::sync::Mutex::new(tx);\\nlet fetcher = collection.fetch_attachment(attachment_token, move |event| {\\n    // completion handler\\n    if let DittoAttachmentFetchEvent::Completed { attachment } = event {\\n        let tx = m_tx.lock().unwrap();\\n        tx.send(attachment).unwrap();\\n    }\\n})?;\\nlet fetched_attachment = rx.recv().unwrap(); // may also use an async version or other sync strategy\\nlet attachment_file_path = fetched_attachment.path();\\nstd::fs::read(attachment_file_path)?;\\n\\n","counter":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": 0}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|x| {\\n        if let Some(doc) = x {\\n            doc.set(\\"owned_cars\\", DittoCounter::new()).unwrap();\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","update":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": 0}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            doc.set(\\"age\\", 32).unwrap();\\n            doc.set(\\"owned_cars\\", DittoCounter::new()).unwrap();\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","query-basic":"collection\\n    .find(\\"favoriteBook.title == \\\\\'The Great Gatsby\\\\\'\\")\\n    .exec()?;\\n\\n","query-args":"let args = json!({\\"name\\": \\"Susan\\", \\"age\\": 32});\\ncollection\\n    .find_with_args(\\"name == $args.name && age <= $args.age\\", args)\\n    .exec()?;\\n\\n","query-sort":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"miles\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .exec()?;\\n\\n","query-limit":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"rank\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .limit(100)\\n    .exec()?;\\n\\n","subscribe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet live_query = store\\n    .collection(\\"cars\\")?\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .subscribe();\\n\\n","sync-observe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet (tx, rx) = channel();\\n{\\n    let live_query = store\\n        .collection(\\"cars\\")?\\n        .find(\\"color == \\\\\'red\\\\\'\\")\\n        .observe_local(move |mut docs: Vec<BoxedDocument>, event| {\\n            match event {\\n                LiveQueryEvent::Initial { .. } => { /* handle if appropriate */ }\\n                LiveQueryEvent::Update { mut insertions, .. } => {\\n                    insertions.sort_by(|a, b| b.cmp(a));\\n                    for idx in insertions.iter() {\\n                        let doc = docs.remove(*idx);\\n                        tx.send(doc).unwrap();\\n                    }\\n                }\\n            }\\n        })?;\\n    store\\n        .collection(\\"cars\\")?\\n        .upsert(json!({\\"color\\": \\"red\\"}))\\n        .unwrap();\\n    for doc in rx.iter() {\\n        println!(\\"New doc {:?}\\", doc);\\n    }\\n} // IMPORTANT: LiveQuery goes out of scope and is Dropped and terminated here.\\n\\n","sync-observe-local":"// Some action in your app ...\\nlet store = ditto.store();\\nstore.collection(\\"cars\\")?.upsert(json!({\\"color\\": \\"red\\"}))?;\\n// Elsewhere register handlers for data changes\\n{\\n    let live_query = store\\n        .collection(\\"cars\\")?\\n        .find(\\"color == \\\\\'red\\\\\'\\")\\n        .observe_local(move |cars, event| {\\n            println!(\\"cars {:?}, event {:?}\\", cars, event);\\n            // do something when data changes\\n            // BUT this closure must be permitted to take ownership\\n        })?;\\n    // stash your live query in something with a long lifetime\\n    // or it will be dropped\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every\\n// application.\\nlet p256_der_b64: &str = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nlet app_id = AppId::from_env(\\"app\\")?;\\nlet ditto = Ditto::builder()\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| identity::SharedKey::new(ditto_root, app_id, p256_der_b64))?\\n    .with_minimum_log_level(CLogLevel::Info)\\n    .build()?;\\nlet res = ditto.set_offline_only_license_token(&license_token);\\nditto.start_sync()?;\\n\\n","online-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        let shared_token = std::env::var(\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\").unwrap();\\n        let enable_cloud_sync = true;\\n        let custom_auth_url = None;\\n        OnlinePlayground::new(\\n            ditto_root,\\n            app_id,\\n            shared_token,\\n            enable_cloud_sync,\\n            custom_auth_url,\\n        )\\n    })?\\n    .build()?;\\n\\nditto.start_sync()?;\\n\\n","offline-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        OfflinePlayground::new(ditto_root, app_id)\\n    })?\\n    .build()?;\\n\\nditto.start_sync()?;\\nlet res = ditto.set_offline_only_license_token(&license_token);\\n\\n","network-remote-ditto":"let mut config = TransportConfig::new(); // empty\\n\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"185.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","network-listen":"let mut config = TransportConfig::new(); // empty\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","network-multiple-transports":"let mut config = TransportConfig::new(); // empty\\n\\n// 1. Enable auto-discovery of peer to peer connections\\nconfig.enable_all_peer_to_peer(); // Auto-connect via lan and bluetooth\\n\\n// 2. Configure TCP Listener\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\n// 3. Configure explicit, hard coded connections\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","transport-sync-groups":"let mut config = TransportConfig::new(); // empty\\n\\n// 1. Enable auto-discovery of peer to peer connections\\nconfig.enable_all_peer_to_peer(); // Auto-connect via lan and bluetooth\\n\\n// 2. Set sync group to an integer between 0 and 2^32\\nconfig.global.sync_group = 12345;\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n"},"objc":{"attachment":"NSBundle *testBundle = [NSBundle bundleForClass:self.class];\\nNSURL *attachmentTestImage = [testBundle URLForResource:@\\"attachment_test\\" withExtension:@\\"png\\"];\\nNSData *attachmentData = [NSData dataWithContentsOfURL:attachmentTestImage];\\n\\nNSDictionary<NSString *, NSString *> *metadata = @{@\\"name\\": @\\"my_image.png\\"};\\nDITAttachment *attachment = [collection newAttachment:attachmentTestImage.path metadata:metadata];\\n\\nDITDocumentID *docID = [collection upsert:@{@\\"some\\": @\\"string\\", @\\"my_attachment\\": attachment} error:nil];\\nDITDocument *doc = [[collection findByID:docID] exec];\\nDITAttachmentToken *attachmentToken = doc[@\\"my_attachment\\"].attachmentToken;\\n\\nDITAttachmentFetcher *fetcher = [collection fetchAttachment:attachmentToken onFetchEvent:^(DITAttachmentFetchEvent *event) {\\n    switch (event.type) {\\n        case DITAttachmentFetchEventTypeCompleted: {\\n            DITAttachmentFetchEventCompleted *completed = [event asCompleted];\\n            DITAttachment *fetchedAttachment = completed.attachment;\\n            NSData *fetchedAttachmentData = [fetchedAttachment getData:nil];\\n            [attachmentRoundtripExpectation fulfill];\\n            break;\\n        }\\n        case DITAttachmentFetchEventTypeProgress:\\n            break;\\n        default:\\n            break;\\n    }\\n}];\\n\\n\\n","counter":"[[collection find:@\\"make == \'Honda\'\\"] updateWithBlock:^(NSArray<DITMutableDocument *> *docs) {\\n    for (DITMutableDocument *doc in docs) {\\n        [doc[@\\"mileage\\"] set:DITCounter.new];\\n        [doc[@\\"mileage\\"].counter incrementBy:1];\\n    }\\n}];\\n\\n","datamodel":"DITCollection *collection = [store collection:@\\"people\\"];\\n\\n","upsert-id":"DITDocumentID *docId = [collection upsert:@{@\\"_id\\": @\\"123abc\\", @\\"name\\": @\\"Susan\\", @\\"age\\": @32 } error:nil];\\nNSLog(@\\"%@\\", docId); // => \\"123abc\\"\\n\\n","upsert":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                         upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                         error:nil];\\n\\n","upsert-composite-primary-key":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                upsert:@{\\n                  @\\"_id\\": @{ @\\"userId\\": @\\"456abc\\", @\\"workId\\": @789 },\\n                  @\\"name\\": @\\"John\\",\\n                  @\\"age\\": @31 }\\n                error:nil];\\nNSLog(@\\"%@\\", docID); // => \\"NSDictionary @{ @\\"userId\\": \\"456abc\\": @\\"workId\\": @789 }\\"\\n\\n","upsert-datatypes":"[[ditto.store collection:@\\"foo\\"]\\n    upsert:@{\\n        @\\"boolean\\": @true,\\n        @\\"string\\": @\\"Hello World\\",\\n        @\\"number\\": @10,\\n        @\\"map\\": @{ @\\"key\\": @\\"value\\" },\\n        @\\"array\\": @[ @1, @2, @3 ],\\n        @\\"null\\": [NSNull null]\\n    }\\n error:nil\\n];\\n\\n","upsert-default-data":"DITDocumentID *defaultDocID = [[ditto.store collection:@\\"people\\"]\\n                               upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                               writeStrategy: DITWriteStrategyInsertDefaultIfAbsent\\n                               error:nil];\\n\\n","query-basic":"NSArray *docs = [[[ditto.store collection:@\\"people\\"]\\n                    find:@\\"favoriteBook.title == \'The Great Gatsby\'\\"] exec];\\n\\n","query-args":"NSArray *documents = [[[ditto.store collection:@\\"people\\"] find:@\\"name == $args.name && age <= $args.age\\" withArgs:@{@\\"age\\": @32, @\\"name\\": @\\"Max\\"}] exec];\\n\\n","remove-query":"NSArray<DITDocumentID *> *removedIDs = [[[ditto.store collection:@\\"people\\"]\\n                                         find:@\\"name == \'Susan\'\\"] remove];\\n\\n","remove-id":"[[[ditto.store collection:@\\"test\\"] findByID:docID] remove];\\n\\n","update":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"] upsert:@{\\n    @\\"name\\": @\\"Frank\\",\\n    @\\"age\\": [NSNumber numberWithInt:31],\\n    @\\"ownedCars\\": [NSNumber numberWithInt:0],\\n} error:nil];\\n\\n\\nDITCollection *collection = [ditto.store collection:@\\"people\\"];\\n[[collection findByID:docID] updateWithBlock:^(DITMutableDocument *doc) {\\n    [doc[@\\"age\\"] set:[NSNumber numberWithInt:32]];\\n    [doc[@\\"ownedCars\\"] set:DITCounter.new];\\n    [doc[@\\"ownedCars\\"].counter incrementBy:1];\\n}];\\n\\n","array-to-map":"[[collection findByID:docID] updateWithBlock:^(DITMutableDocument *doc) {\\n    NSMutableDictionary *map = [NSMutableDictionary new];\\n    NSArray *names = doc[@\\"friends\\"].arrayValue;\\n    for (id name in names) {\\n        NSString *uuid = [[NSUUID UUID] UUIDString];\\n        map[uuid] = @{\\n            @\\"id\\": uuid,\\n            @\\"name\\": name\\n        };\\n    }\\n    [doc[@\\"friendsMap\\"] set:map];\\n}];\\n\\n","query-sort":"NSArray *sortedRedCars = [[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending] exec];\\n\\n","query-limit":"NSArray *sortedAndLimitedRedCars = [[[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending]\\n                  limit:100] exec];\\n\\n","sync-basic":"NSError *error = nil;\\n[ditto startSync:&error];\\n\\n","write-transaction":"NSArray *results = [store write:^(DITWriteTransaction *tx) {\\n    DITScopedWriteTransaction *cars = tx[@\\"cars\\"];\\n    DITScopedWriteTransaction *people = tx[@\\"people\\"];\\n    DITDocumentID *docID = [[DITDocumentID alloc] initWithValue: @\\"abc123\\"];\\n    [people upsert:@{@\\"_id\\": docID, @\\"name\\": @\\"Susan\\"} error:nil];\\n    [cars upsert:@{@\\"make\\": @\\"Ford\\", @\\"color\\": @\\"black\\", @\\"owner\\": docID} error:nil];\\n    [cars upsert:@{@\\"make\\": @\\"Toyota\\", @\\"color\\": @\\"red\\", @\\"owner\\": docID} error:nil];\\n}];\\n\\n","sync-observe":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","subscribe":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITSubscription *subscription = [[collection find:@\\"color == \'red\'\\"] subscribe];\\n\\n","sync-observe-local":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\n\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nNSString *p256_der_b64 = @\\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDITIdentity *identity = [[DITIdentity alloc] initSharedKeyWithAppID:@\\"app\\" sharedKey:p256_der_b64];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\n\\nNSError *error = nil;\\nif (![ditto setOfflineOnlyLicenseToken:validLicense error:&error]) {\\n    NSLog(@\\"Error setting license: %@\\", error);\\n}\\n\\n","online-playground":"DITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"\\n                                                                     token:@\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"\\n                                                      enableDittoCloudSync:YES];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity persistenceDirectory: dittoPersistenceDir];\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","offline-playground":"DITIdentity *identity = [[DITIdentity alloc] initOfflinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nNSError *error = nil;\\nif (![ditto setOfflineOnlyLicenseToken:validLicense error:&error]) {\\n  NSLog(@\\"Error setting license: %@\\", error);\\n}\\nif (![ditto startSync:&error]) {\\n  NSLog(@\\"Error starting sync: %@\\", error);\\n}\\n[ditto startSync:&error];\\n\\n","network-remote-ditto":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-listen":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-multiple-transports":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n// 1. Enable Local Area Network Connections\\n[transportConfig enableAllPeerToPeer];\\n// 2. Listen for incoming connections on port 4000\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n// 3. Connect explicitly to remote devices\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nDITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"REPLACE_WITH_APP_ID\\" token:@\\"REPLACE_WITH_PLAYGROUND_TOKEN\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nditto.delegate = self;\\n[ditto startSync:nil];\\n\\n// Now you can observe real time changes to the transport conditions:\\n@interface ViewController () <DITDittoDelegate>\\n\\n@end\\n\\n@implementation ViewController\\n\\n- (void)transportConditionChanged:(enum DITTransportCondition)condition forSubsystem:(enum DITConditionSource)source {\\n    if (condition == DITTransportConditionBleDisabled) {\\n        NSLog(@\\"BLE disabled\\");\\n    } else if (condition == DITTransportConditionNoBleCentralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    } else if (condition == DITTransportConditionNoBlePeripheralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    }\\n}\\n\\n@end\\n\\n","network-query-overlap-group":"NSString *const orders = @\\"orders\\";\\n\\n// The passenger only observes orders that they created\\n[[[passenger.store collection:orders] find:@\\"user_id==abc123\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render my orders in a list UI\\n}];\\n\\n// Crew member devices observe all orders that everyone created\\n[[[crewA.store collection:orders] find:@\\"status == \'OPEN\'\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render all orders in a list UI\\n}];\\n\\n[[[crewB.store collection:orders] find:@\\"status == \'OPEN\'\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render all orders\\n}];\\n\\n// Set up our query overlap group and priorities such that the crew members\\n// will construct multihop connections with each other.\\n[DITExperimental setQueryOverlapGroup:2 ditto:crewA];\\n[DITExperimental setQueryOverlapGroup:2 ditto:crewB];\\n\\n// Query overlap groups should be set before startSync\\n[crewA startSync:nil];\\n[crewB startSync:nil];\\n[passenger startSync:nil];\\n\\n","network-set-priority":"[DITExperimental setPriority:DITConnectionPriorityHigh\\n                 forQueryOverlapGroup:2 ditto:crewA];\\n[DITExperimental setPriority:DITConnectionPriorityHigh\\n        forQueryOverlapGroup:2 ditto:crewB];\\n\\n","transport-sync-groups":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n// 1. Enable All Peer to Peer Connection\\n[transportConfig enableAllPeerToPeer];\\n// 2. Set sync group to an integer between 0 and 2^32\\ntransportConfig.global.syncGroup = 12312;\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","evict":"NSArray<DITDocumentID *> *evictedIDs = [[collection find:@\\"make == \'Honda\'\\"] evict];\\n\\n"},"swift":{"shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nlet p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\n\\nlet identity = DittoIdentity.sharedKey(appID: \\"app\\", sharedKey: p256DerB64)\\nlet ditto = Ditto(identity: identity, persistenceDirectory: dittoPersistenceDir)\\ndo {\\n    try ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","write-transaction":"ditto.store.write { transaction in\\n    let cars = transaction.scoped(toCollectionNamed: \\"cars\\")\\n    let people = transaction.scoped(toCollectionNamed: \\"people\\")\\n    let docId = \\"abc123\\"\\n    do {\\n        try people.upsert([\\"_id\\": docId, \\"name\\": \\"Susan\\"] as [String: Any?])\\n        try cars.upsert([\\"make\\": \\"Ford\\", \\"color\\": \\"red\\", \\"owner\\": docId] as [String: Any?])\\n        try cars.upsert([\\"make\\": \\"Toyota\\", \\"color\\": \\"black\\", \\"owner\\": docId] as [String: Any?])\\n    } catch (let err) {\\n      print(err.localizedDescription)\\n    }\\n    people.findByID(docId).evict()\\n}\\n\\n","online-playground":"let ditto = Ditto(identity: DittoIdentity.onlinePlayground(\\n    appID: \\"00000000-0000-4000-0000-000000000000\\",\\n    token: \\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"\\n))\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","offline-playground":"var ditto = Ditto(identity: DittoIdentity.offlinePlayground(\\n    appID: \\"00000000-0000-4000-0000-000000000000\\"\\n))\\ntry! ditto.setOfflineOnlyLicenseToken(validLicense);\\ntry! ditto.startSync()\\n\\n","datamodel":"let carsCollection = ditto.store[\\"cars\\"]\\n// or\\nlet carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","attachment":"let collection = ditto.store[\\"foo\\"]\\n\\nlet myImageURL = bundle.url(forResource: \\"image\\", withExtension: \\"png\\")!\\n\\nlet metadata = [\\"name\\": \\"my_image.png\\"]\\nlet attachment = collection.newAttachment(\\n    path: myImageURL.path,\\n    metadata: metadata\\n)!\\n\\nguard let docID = try? collection.upsert([\\"some\\": \\"string\\", \\"my_attachment\\": attachment]) else{\\n    //hanlde error\\n    return\\n}\\n\\n// Later, find the document and the fetch the attachment\\n\\nlet doc = collection.findByID(docID).exec()\\nlet attachmentToken = doc![\\"my_attachment\\"].attachmentToken!\\n\\nlet fetcher = collection.fetchAttachment(token: attachmentToken) { status in\\n    switch status {\\n    case .completed(let fetchedAttachment):\\n        // Do something with attachment\\n        break\\n    default:\\n        print(\\"Unable to fetch attachment\\")\\n        break\\n    }\\n}\\n\\n","upsert-default-data":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ], writeStrategy: .insertDefaultIfAbsent)\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-composite-primary-key":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"_id\\": [ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ],\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n    print(docID) // \\"[ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ]\\"\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-datatypes":"do {\\n    // Insert JSON-compatible data into Ditto\\n    try ditto.store[\\"foo\\"].upsert([\\n        \\"boolean\\": true,\\n        \\"string\\": \\"Hello World\\",\\n        \\"number\\": 10,\\n        \\"map\\": [\\"key\\": \\"value\\"],\\n        \\"array\\": [1,2,3],\\n        \\"null\\": nil\\n    ])\\n}\\ncatch {\\n    //handle error\\n    print(error)\\n}\\n\\n","counter":"do {\\n    let docId = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Frank\\",\\n        \\"ownedCars\\": 0 // here 0 is a number\\n    ])\\n\\n    ditto.store[\\"people\\"].findByID(docId).update({ mutableDoc in\\n        mutableDoc?[\\"ownedCars\\"].set(DittoCounter())\\n        mutableDoc?[\\"ownedCars\\"].counter?.increment(by: 1)\\n    })\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","update":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Frank\\",\\n        \\"age\\": 31,\\n        \\"ownedCars\\": 0\\n    ])\\n\\n    ditto.store[\\"people\\"].findByID(docID).update { mutableDoc in\\n        mutableDoc?[\\"age\\"] = 32\\n        mutableDoc?[\\"ownedCars\\"].set(DittoCounter())\\n        mutableDoc?[\\"ownedCars\\"].counter?.increment(by: 1)\\n    }\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","array-to-map":"collection.findByID(docID).update { doc in\\n    guard let doc = doc else {\\n        print(\\"Document with id=\\\\(docID) not found\\")\\n        return\\n    }\\n\\n    let names = doc[\\"friends\\"].arrayValue\\n    var dict = Dictionary<String, Any>()\\n\\n    _ = names.map { name in\\n        let friend: NSMutableDictionary = [:]\\n        let id = UUID().uuidString\\n        friend[\\"id\\"] = id\\n        friend[\\"name\\"] = name\\n        dict.updateValue(friend, forKey: id)\\n    }\\n    doc[\\"friendsMap\\"].set(dict)\\n}\\n\\n","upsert":"do {\\n    // upsert JSON-compatible data into Ditto\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-id":"do {\\n    // upsert JSON-compatible data into Ditto\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"_id\\": \\"abc123\\",\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n    XCTAssertEqual(docID, \\"abc123\\")\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","query-basic":"let collection = ditto.store[\\"people\\"]\\n    .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"let documents = ditto.store[\\"users\\"].find(\\"name == $args.name && age <= $args.age\\", args: [\\n    \\"age\\": 32,\\n    \\"name\\": \\"Max\\"\\n]).exec()\\n\\n","query-sort":"let sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .exec()\\n\\n","query-limit":"let sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfunc userDidInsertCar() {\\n    _ = try? ditto.store.collection(\\"cars\\").upsert([\\n        \\"model\\": \\"Ford\\",\\n        \\"color\\": \\"black\\"\\n    ] as [String: Any?])\\n}\\n\\n// Register live query to update UI\\nlet liveQuery = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n    .observeLocal { cars, event in\\n        // do something\\n    }\\n\\n","sync-observe":"// Register live query to update UI\\nlet example = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n   .observeLocal { cars, event in\\n     // do something\\n}\\n\\n","subscribe":"// Register live query to update UI\\nlet subscription = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\").subscribe()\\n\\n","network-remote-ditto":"let config = DittoTransportConfig()\\n// Connect explicitly to a remote devices\\nconfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\"\\nlet observer = ditto.presence.observe { presence in\\n    if !presence.remotePeers.isEmpty {\\n        // render peers\\n    }\\n}\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-listen":"let config = DittoTransportConfig()\\n\\n// Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-multiple-transports":"var config = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\nconfig.enableAllPeerToPeer()\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nlet ditto = Ditto(identity: DittoIdentity.onlinePlayground(appID: \\"00000000-0000-4000-0000-000000000000\\", token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.delegate = self\\ntry! ditto.startSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\nextension ViewController: DittoDelegate {\\n   func transportConditionDidChange(transportID: Int64, condition: TransportCondition) {\\n       if condition == .BleDisabled {\\n           print(\\"BLE disabled\\")\\n       } else if condition == .NoBleCentralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       } else if condition == .NoBlePeripheralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       }\\n   }\\n\\n\\n","transport-sync-groups":"struct User {\\n    var id: String\\n    var restaurantId: UInt32\\n}\\nlet authenticatedUser = User(id: \\"abc123\\", restaurantId: 323234)\\n\\nvar config = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections \\nconfig.enableAllPeerToPeer()\\n// 2. Set sync group to an integer between 0 and 2^32\\nconfig.global.syncGroup = authenticatedUser.restaurantId\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-query-overlap-group":"// The passenger only observes orders that they created\\nlet passengerQuery = passenger.store.collection(\\"orders\\").find(\\"user_id==abc123\\")\\nlet passengerSubscription = passengerQuery.subscribe()\\nlet passengerLiveQuery = passengerQuery.observeLocal { docs, event in\\n  // render passenger orders in a list UI\\n}\\n\\n// Crew member devices observe all orders that everyone created\\nlet crewAQuery = crewA.store.collection(\\"orders\\").findAll()\\nlet crewASubscription = crewAQuery.subscribe()\\nlet crewALiveQuery = crewAQuery.observeLocal { docs, event in\\n  // render all orders in a list UI\\n}\\nlet crewBQuery = crewB.store.collection(\\"orders\\").findAll()\\nlet crewBSubscription = crewBQuery.subscribe()\\nlet crewBLiveQuery = crewBQuery.observeLocal { docs, event in\\n  // render all orders in a list UI\\n}\\n\\n// Set up our query overlap group and priorities such that the crew members\\n// will construct multihop connections with each other.\\nDittoExperimental.setQueryOverlapGroup(queryOverlapGroup: 2, ditto: crewA)\\nDittoExperimental.setQueryOverlapGroup(queryOverlapGroup: 2, ditto: crewB)\\n\\n// Query overlap groups should be set before startSync\\ntry! passenger.startSync()\\ntry! crewA.startSync()\\ntry! crewB.startSync()\\n\\n","network-set-priority":"DittoExperimental.setPriority(DittoConnectionPriority.high, forQueryOverlapGroup: 2, ditto: crewA)\\nDittoExperimental.setPriority(DittoConnectionPriority.high, forQueryOverlapGroup: 2, ditto: crewB)\\n\\n","evict":"collection.find(\\"owner == \'Bob\'\\").evict()\\n\\n","remove-query":"collection.find(\\"owner == \'Bob\'\\").remove()\\n\\n","remove-id":"collection.findByID(docID).remove()\\n\\n","sync-basic":"try! ditto.startSync()\\n\\n"},"cpp":{"sync-observe-local":"// --- Register live query to update UI\\nstd::shared_ptr<LiveQuery> query =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe_local([&](std::vector<Document> docs, LiveQueryEvent event) {\\n\\n        });\\n\\n","datamodel":"Collection cars_collection = ditto.get_store().collection(\\"cars\\");\\n\\n","upsert-id":"json person = json({{\\"_id\\", \\"123abc\\"}, {\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert":"json person = json({{\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert-composite-primary-key":"json content = json({{\\"_id\\", {{\\"userId\\", \\"456abc\\"}, {\\"workId\\", 789}}},\\n                     {\\"name\\", \\"Susan\\"},\\n                     {\\"age\\", 31}});\\nDocumentId doc_ID = ditto.get_store().collection(\\"people\\").upsert(content);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nditto.get_store().collection(\\"foo\\").upsert(json({{\\"boolean\\", true},\\n                                                 {\\"string\\", \\"Hello World\\"},\\n                                                 {\\"number\\", 10},\\n                                                 {\\"map\\", {{\\"key\\", \\"value\\"}}},\\n                                                 {\\"array\\", {1, 2, 3}},\\n                                                 {\\"null\\", NULL}}));\\n\\n","write-transaction":"auto results = ditto.get_store().write([&](WriteTransaction &write_txn) {\\n  ScopedWriteTransaction people = write_txn.scoped(\\"people\\");\\n  ScopedWriteTransaction cars = write_txn.scoped(\\"cars\\");\\n  auto docId = \\"abc123\\";\\n  people.upsert({{\\"name\\", \\"Susan\\"}, {\\"_id\\", DocumentId(docId)}});\\n  cars.upsert({{\\"make\\", \\"Hyundai\\"}, {\\"owner\\", DocumentId(docId)}});\\n  cars.upsert({{\\"make\\", \\"Toyota\\"}, {\\"owner\\", DocumentId(docId)}});\\n});\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared\\n// key for every application.\\nconst std::string p256_der_b64 =\\n    \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4\\"\\n    \\"hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlq\\"\\n    \\"nfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDitto ditto = ditto::Ditto(Identity::SharedKey(\\"\\", p256_der_b64), path);\\nditto.set_offline_only_license_token(valid_license);\\n\\n","attachment":"auto attachment_file_path = fs::path(images_path.string() + \\"/image.png\\");\\nstd::map<std::string, std::string> metadata = {{\\"some\\", \\"string\\"}};\\n\\nAttachment attachment =\\n    collection.new_attachment(attachment_file_path.string(), metadata);\\n\\nauto doc_id =\\n    collection.upsert({{\\"some\\", \\"string\\"}, {\\"my_attachment\\", attachment}});\\n\\n// Later, find the document and the fetch the attachment\\nauto doc = collection.find_by_id(doc_id).exec();\\nauto att_token = (*doc)[\\"my_attachment\\"].get_attachment_token();\\n\\nauto fetcher = collection.fetch_attachment(\\n    att_token,\\n    AttachmentFetcherEventHandler{\\n        [&](std::unique_ptr<AttachmentFetchEvent> event) {\\n          switch (event->type) {\\n          case AttachmentFetchEventType::Completed: {\\n            AttachmentFetchEventCompleted *completed_event =\\n                static_cast<AttachmentFetchEventCompleted *>(event.get());\\n            Attachment fetched_attachment = completed_event->attachment;\\n            // Do something with attachment\\n            break;\\n          }\\n          default:\\n            std::cout << \\"Unable to fetch attachment\\" << std::endl;\\n          }\\n        }});\\n\\n","array-to-map":"ditto.get_store().collection(\\"people\\").find_by_id(docID).update(\\n    [](MutableDocument &doc) {\\n      auto friendsMap = json::object();\\n      auto array = doc[\\"friends\\"].get_json();\\n      for (size_t i = 0; i < array.size(); i++) {\\n        auto name = array[i];\\n        friendsMap[\\"my_id\\"] = json({{\\"name\\", name}, {\\"id\\", \\"my_id\\"}});\\n      };\\n      doc[\\"friendsMap\\"].set(friendsMap);\\n    });\\n\\n","counter":"DocumentId docID = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"ownedCars\\", 0}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(docID).update(\\n    [](MutableDocument &doc) {\\n      doc[\\"ownedCars\\"].set(Counter());\\n      auto counter = doc[\\"ownedCars\\"].get_counter();\\n      counter->increment(1);\\n    });\\n\\n","update":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"age\\", 31}, {\\"ownedCars\\", 0}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(doc_id).update(\\n    [](MutableDocument &doc) {\\n      doc[\\"age\\"].set(32);\\n      doc[\\"ownedCars\\"].set(Counter());\\n      auto counter = doc[\\"ownedCars\\"].get_counter();\\n      counter->increment(1);\\n    });\\n\\n","remove-id":"ditto.get_store().collection(\\"people\\").find_by_id(doc_id).remove();\\n\\n","remove-query":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-default-data":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    content, WriteStrategy::insertDefaultIfAbsent);\\n\\n","query-basic":"std::vector<Document> results =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"json args = json({{\\"age\\", 32}, {\\"name\\", \\"max\\"}});\\nstd::vector<Document> big_c_values =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", args)\\n        .exec();\\n\\n","query-sort":"std::vector<Document> sorted_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .exec();\\n\\n","query-limit":"std::vector<Document> sorted_and_limited_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n  std::cerr << err.what();\\n}\\n\\n","subscribe":"std::shared_ptr<ditto::Subscription> subscription =\\n    collection.find(\\"color == \'red\'\\").subscribe();\\n\\n","sync-observe":"std::shared_ptr<LiveQuery> liveQuery =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe_local([&](std::vector<Document> docs, LiveQueryEvent event) {\\n          // do something\\n        });\\n\\n","online-playground":"Ditto ditto;\\nauto identity =\\n    Identity::OnlinePlayground(\\"00000000-0000-4000-0000-000000000000\\",\\n                               \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\", true);\\ntry {\\n  ditto = Ditto(identity, dir);\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","offline-playground":"Ditto ditto;\\nauto identity =\\n    Identity::OfflinePlayground(\\"00000000-0000-4000-0000-000000000000\\", 1234);\\ntry {\\n  ditto = Ditto(identity, dir);\\n\\n  ditto.set_offline_only_license_token(valid_license);\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","network-remote-ditto":"auto config = ditto::TransportConfig();\\n// Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\n// set the transport config\\nditto.set_transport_config(config);\\n// now you can start ditto\'s sync\\nditto.start_sync();\\n\\n","network-listen":"auto config = ditto::TransportConfig();\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n","transport-sync-groups":"auto config = ditto::TransportConfig();\\nconfig.enable_all_peer_to_peer();\\nconfig.global.sync_group = 12345;\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n","network-multiple-transports":"auto config = ditto::TransportConfig();\\n// 1. Enable All Peer to Peer Connections\\nconfig.enable_all_peer_to_peer();\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n"},"http":{"upsert-composite-primary-key":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": { \\n          \\"user_id\\": \\"456abc\\",\\n          \\"work_id\\": 789\\n        },\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"abc123\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert-id":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"456abc\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert-datatypes":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"456abc\\",\\n        \\"value\\": {\\n          \\"boolean\\": true, \\n          \\"string\\": \\"Hello World\\",\\n          \\"number\\": 10,\\n          \\"map\\": {\\n            \\"key\\": \\"value\\",\\n          },\\n          \\"array\\": [1,2,3],\\n          \\"null\\": null\\n        }\\n      }]\\n  }\'\\n\\n","update":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"123abc\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Frank\\", \\n          \\"age\\": 32,\\n          \\"friends\\": [\\"Susan\\"],\\n          \\"owned_cars\\": 0\\n        }\\n      }]\\n  }\'\\n\\n","query-basic":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"favoriteBook.title == \'The Great Gatsby\'\\"\\n  }\'\\n\\n","query-args":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"args\\": {\\n      \\"name\\": \\"max\\",\\n      \\"age\\": 32\\n    },\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"name == $args.name && age <= $args.age\\"\\n  }\'\\n\\n","query-limit":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"color == \'red\'\\",\\n    \\"limit\\": 100\\n  }\'\\n\\n","remove-id":"curl --location --request POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"remove\\",\\n        \\"collection\\": \\"orders\\",\\n        \\"query\\": \\"_id == \'<ID>\'\\"\\n      }]\\n  }\'\\n\\n"},"javascript":{"online-playground":"import { init, Ditto } from \\"@dittolive/ditto\\"\\nconst identity: Identity = { type: \'onlinePlayground\', appID: \'00000000-0000-4000-0000-000000000000\', token: \'REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\' }\\nconst ditto = new Ditto(identity, path)\\nditto.startSync()\\n\\n","offline-playground":"const identity: Identity = { type: \'offlinePlayground\', appID: \'00000000-0000-4000-0000-000000000000\' }\\nconst ditto = new Ditto(identity, path)\\nditto.setOfflineOnlyLicenseToken(validLicense)\\nditto.startSync()\\n\\n","datamodel":"const carsCollection = ditto.store.collection(\'cars\')\\n\\n","upsert-id":"const docID = await ditto.store.collection(\'people\').upsert({\\n  _id: \'123abc\',\\n  name: \'Susan\',\\n  age: 31,\\n})\\n\\nconsole.log(docID) // \\"123abc\\"\\n\\n","upsert":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docID) // \\"507f191e810c19729de860ea\\"\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nawait ditto.store.collection(\'people\').upsert({\\n  boolean: true,\\n  string: \'Hello World\',\\n  number: 10,\\n  map: { key: \'value\' },\\n  array: [],\\n  null: null,\\n})\\n\\n","counter":"const frankId = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  ownedCars: 0, // here 0 is a number\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(frankId)\\n  .update((mutableDoc) => {\\n    mutableDoc.at(\'ownedCars\').set(new Counter())\\n    mutableDoc.at(\'ownedCars\').counter.increment(1)\\n  })\\n\\n","upsert-default-data":"const docID = await ditto.store.collection(\'people\').upsert(\\n  {\\n    name: \'Susan\',\\n    age: 31,\\n  },\\n  { writeStrategy: \'insertDefaultIfAbsent\' },\\n)\\n\\n","upsert-composite-primary-key":"const docID = await ditto.store.collection(\'people\').upsert({\\n  _id: { userID: \'456abc\', workID: 789 },\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docID) // \\"{ \\"userID\\": \\"456abc\\", \\"workID\\": 789 }\\"\\n\\n","update":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  age: 31,\\n  ownedCars: 0,\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(docID)\\n  .update((mutableDoc) => {\\n    mutableDoc.at(\'age\').set(32)\\n\\n    mutableDoc.at(\'ownedCars\').set(new Counter())\\n    mutableDoc.at(\'ownedCars\').counter.increment(1)\\n  })\\n\\n","array-to-map":"await collection.findByID(docID).update((mutableDoc) => {\\n  const map = {}\\n  const array = mutableDoc.at(\'friends\').value\\n  array.forEach((name) => {\\n    const id = getUUID()\\n    map[id] = { id, name }\\n  })\\n  mutableDoc.at(\'friendsMap\').set(map)\\n})\\n\\n","query-basic":"const collection = await ditto.store.collection(\'people\').find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n\\n","remove-id":"await ditto.store.collection(\'people\').findByID(docID).remove()\\n\\n","query-args":"const query = \'name == $args.name && age <= $args.age\'\\nconst documents = await ditto.store.collection(\'people\').find(query, {\\n  age: 32,\\n  name: \'Max\',\\n})\\n\\n","remove-query":"await ditto.store.collection(\'people\').find(\'age <= 32\').remove()\\n\\n","query-sort":"const sortedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\')\\n\\n","query-limit":"const sortedAndLimitedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\').limit(100)\\n\\n","evict":"await ditto.store.collection(\'people\').find(\'age <= 32\').evict()\\n\\n","sync-basic":"try {\\n  ditto.startSync()\\n} catch (err) {\\n  console.error(err)\\n}\\n\\n","sync-observe":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observeLocal((cars, event) => {\\n    // do something\\n  })\\n\\n","subscribe":"const subscription = ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").subscribe()\\n\\n","sync-observe-local":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observeLocal((cars, event) => {\\n    // do something\\n  })\\n\\n","attachment":"const collection = ditto.store.collection(\'foo\')\\n\\nconst myImageBase64 = \'iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEW10NBjBBbqAAAAH0lEQVRoge3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAvg0hAAABmmDh1QAAAABJRU5ErkJggg==\'\\nconst myImageBytes = Uint8Array.from(myImageBase64, (character) => character.charCodeAt(0))\\nconst metadata = { name: \'image.png\' }\\n\\n// On Node, you can also pass a file path (string) instead of image data\\n// and the attachment will be created from that file.\\nconst attachment = await collection.newAttachment(myImageBytes, metadata)\\n\\nconst docID = await collection.upsert({ some: \'string\', my_attachment: attachment })\\n\\n// Later, find the document and then fetch the attachment\\n\\nconst doc = await collection.findByID(docID)\\nconst attachmentToken = doc.at(\'my_attachment\').attachmentToken\\n\\nconst attachmentFetcher = collection.fetchAttachment(attachmentToken, async (attachmentFetchEvent) => {\\n  switch (attachmentFetchEvent.type) {\\n    case \'Completed\':\\n      const fetchedAttachment = attachmentFetchEvent.attachment\\n      // Do something with attachment\\n      break\\n\\n    default:\\n      console.log(\'Unable to fetch attachment\')\\n      break\\n  }\\n})\\n\\n// There is also a more convenient way of fetching the attachment\\n// (AttachmentFetcher implements the `PromiseLike` protocol):\\nconst fetchedAttachment = await collection.fetchAttachment(attachmentToken)\\n// Do something with attachment\\n\\n","network-remote-ditto":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.connect.websocketURLs.push(\'wss://135.1.5.5:12345\')\\nconfig.connect.websocketURLs.push(\'wss://185.1.5.5:12345\')\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n\\n","network-monitor-conditions":"const transportConditionsObserver = ditto.observeTransportConditions((condition, source) => {\\n  if (condition === \'BLEDisabled\') {\\n    console.log(\'BLE disabled\')\\n  } else if (condition === \'NoBLECentralPermission\') {\\n    console.log(\'Permission missing for BLE\')\\n  } else if (condition === \'NoBLEPeripheralPermission\') {\\n    console.log(\'Permissions missing for BLE\')\\n  }\\n})\\n\\n","network-multiple-transports":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\n// 1. Enable All Peer to Peer Connections (not in a browser environment)\\nconfig.setAllPeerToPeerEnabled(true)\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","network-listen":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","transport-sync-groups":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\n// 1. Enable All Peer to Peer Connections (not in a browser environment)\\nconfig.setAllPeerToPeerEnabled(true)\\n// 2. Set sync group to an integer between 0 and 2^32\\nconfig.global.syncGroup = 12345\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n"},"csharp":{"sync-basic":"try\\n{\\n    onlineDitto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    // handle exception\\n}\\n\\n","remove-query":"ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Remove();\\n\\n","remove-id":"var wasRemoved = coll.FindById(docId).Remove();\\n\\n","counter":"var counter = new DittoCounter();\\n\\nvar docId = coll.Upsert(new Dictionary<string, object> {\\n    { \\"make\\", \\"Honda\\" }, { \\"mileage\\", counter }\\n});\\n\\n_ = coll.FindById(docId).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"mileage\\"].Counter.Increment(100);\\n});\\n\\n","update":"var content = new Dictionary<string, object>\\n{\\n    { \\"name\\", \\"Bob\\" },\\n    { \\"age\\", 40 },\\n    { \\"ownedCars\\",  new DittoCounter() }\\n};\\n\\nvar docId = Ditto.Store.Collection(\\"people\\").Upsert(content);\\nDitto.Store.Collection(\\"people\\").FindById(docId).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"age\\"].Set(32);\\n    mutableDoc[\\"ownedCars\\"].Counter.Increment(1);\\n});\\n\\n","evict":"Ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Evict();\\n\\n","array-to-map":"Ditto.Store.Collection(\\"people\\").FindById(docId).Update(mutableDoc =>\\n{\\n    var friendsMap = new Dictionary<string, object>();\\n\\n    foreach (string name in mutableDoc[\\"friends\\"].ListValue)\\n    {\\n        var friend = new Dictionary<string, object>();\\n        var id = \\"myId\\";\\n        friend[\\"id\\"] = id;\\n        friend[\\"name\\"] = name;\\n        mutableDoc[id].Set(friend);\\n    }\\n    mutableDoc[\\"friendsMap\\"].Set(friendsMap);\\n});\\n\\n","attachment":"string attachmentImagePath = Path.Combine(Directory.GetCurrentDirectory(), \\"attachment_test.png\\");\\n\\nvar originalBytes = File.ReadAllBytes(attachmentImagePath);\\n\\nvar metadata = new Dictionary<string, string> { { \\"name\\", \\"my_image.png\\" } };\\nvar attachment = coll.NewAttachment(attachmentImagePath, metadata);\\n\\nvar docId = coll.Upsert(new Dictionary<string, object> { { \\"some\\", \\"string\\" }, { \\"my_attachment\\", attachment } });\\n\\nvar doc = coll.FindById(docId).Exec();\\nvar attachmentToken = doc[\\"my_attachment\\"].AttachmentToken;\\nusing var fetcher = coll.FetchAttachment(attachmentToken, ev =>\\n{\\n    switch (ev)\\n    {\\n        case DittoAttachmentFetchEvent.Completed e:\\n            // Do something with attachment\\n            break;\\n        default:\\n            Console.WriteLine(\\"Unable to fetch attachment\\");\\n            break;\\n    }\\n});\\n\\n","upsert-composite-primary-key":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object> {\\n    { \\"_id\\", new Dictionary<string, object> {{ \\"userId\\", \\"456abc\\" }, { \\"workId\\", 789 }} },\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 }\\n};\\nvar docId = ditto.Store.Collection(\\"people\\").Upsert(content);\\n\\n","upsert-default-data":"// Immediately try and insert some new default data\\nvar docId = coll.Upsert(\\n    new Dictionary<string, object> { { \\"name\\", \\"Susan\\" } },\\n    DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","datamodel":"var coll = ditto.Store.Collection(\\"people\\");\\n\\n","upsert":"var docId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 },\\n    }\\n);\\n\\n","upsert-id":"var returnedId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n        { \\"_id\\", \\"123abc\\" },\\n        { \\"name\\", \\"Joe\\" },\\n        { \\"age\\", 32 },\\n        { \\"isOnline\\", true }\\n    }\\n);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object>\\n{\\n    { \\"boolean\\", true },\\n    { \\"string\\", \\"Hello World\\" },\\n    { \\"number\\", 10 },\\n    { \\"map\\", new Dictionary<string, string>{{ \\"key\\", \\"value\\"}} },\\n    { \\"array\\", new[] {1, 2, 3} },\\n    { \\"null\\", null }\\n};\\nDitto.Store.Collection(\\"foo\\").Upsert(content);\\n\\n","online-playground":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OnlinePlayground(\\"00000000-0000-4000-0000-000000000000\\", \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\", true), path);\\n    ditto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","offline-playground":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OfflinePlayground(\\"00000000-0000-4000-0000-000000000000\\", 0), path);\\n    ditto.StartSync();\\n    ditto.SetOfflineOnlyLicenseToken(validLicense);\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nstring p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nvar identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64);\\nvar ditto = new Ditto(identity);\\ntry\\n{\\n    ditto.SetOfflineOnlyLicenseToken(validLicense);\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","query-basic":"var results = ditto.Store.Collection(\\"people\\")\\n    .Find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .Exec();\\n\\n","query-args":"var docs = ditto.Store\\n    .Collection(\\"users\\")\\n    .Find(\\n        \\"name == $args.name && age <= $args.age\\",\\n        new Dictionary<string, object> { { \\"name\\", \\"max\\" }, { \\"age\\", 32 } })\\n    .Exec();\\n\\n","query-sort":"var sortedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Exec();\\n\\n","query-limit":"var sortedAndLimitedRedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Limit(100).Exec();\\n\\n","subscribe":"// --- Register live query to update UI\\nvar subscription = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .Subscribe();\\n\\n","sync-observe":"// --- Register live query to update UI\\nvar liveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\").ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\").ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","sync-observe-local":"// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","network-remote-ditto":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n// Connect explicitly to a remote device on\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\n// you can add as many TcpServers as you would like.\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:4567\\");\\n// set the transport config\\nDitto.TransportConfig = transportConfig;\\n// now you can start ditto\'s sync\\nDitto.StartSync();\\n\\n","network-listen":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\ntransportConfig.Listen.Tcp = new DittoTcpListenConfig();\\n// By default Listen.Tcp.Enabled is false, be sure to set it to true.\\ntransportConfig.Listen.Tcp.Enabled = true;\\n// if you want to listen on localhost, most likely you will use 0.0.0.0\\n// do not use \\"localhost\\" as a string\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\n// specify your port.\\ntransportConfig.Listen.Tcp.Port = 4000;\\nDitto.TransportConfig = transportConfig;\\n\\n// now you can call `ditto.StartSync()`\\nDitto.StartSync();\\n\\n","network-multiple-transports":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n\\n// 1. Enable Local Area Network Connections\\ntransportConfig.EnableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.Listen.Tcp.Enabled = true;\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\ntransportConfig.Listen.Tcp.Port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:12345\\");\\n\\nditto.TransportConfig = transportConfig;\\n\\nditto.StartSync();\\n\\n","network-set-priority":"DittoExperimental.SetPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2, crewB);\\nDittoExperimental.SetPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2, crewA);\\n\\n","transport-sync-groups":"var user = {\\n    { \\"id\\": \\"abc123\\", \\"restaurantId\\": 54123}\\n}\\nDittoTransportConfig transportConfig = new DittoTransportConfig();\\n// 1. Enable All Peer to Peer Connections \\ntransportConfig.EnableAllPeerToPeer();\\n// 2. Set sync group to an integer between 0 and 2^32\\ntransportConfig.global.syncGroup = user.restaurantId;\\nditto.TransportConfig = transportConfig;\\n\\nditto.StartSync();\\n\\n"},"kotlin":{"attachment":"val testContext = InstrumentationRegistry.getInstrumentation().context\\nval attachmentStream = testContext.assets.open(\\"attachment_test.png\\")\\n\\nval bitmapStream = testContext.assets.open(\\"attachment_test.png\\")\\nval attachmentBitmap = BitmapFactory.decodeStream(bitmapStream)\\nbitmapStream.close()\\n\\nval metadata = mapOf(\\"name\\" to \\"my_image.png\\")\\nval attachment = coll.newAttachment(attachmentStream, metadata)\\n\\nval docId = coll.upsert(mapOf(\\"some\\" to \\"string\\", \\"my_attachment\\" to attachment))\\nval doc = coll.findById(docId).exec()\\nval attachmentToken = doc!![\\"my_attachment\\"].attachmentToken\\n\\nval fetcher = coll.fetchAttachment(attachmentToken!!) {\\n    when (it) {\\n        is Completed -> {\\n            val attBitmap: Bitmap = BitmapFactory.decodeStream(it.attachment.getInputStream())\\n        }\\n        is Progress -> {}\\n    }\\n}\\n\\n","datamodel":"val carsCollection = ditto.store[\\"cars\\"]\\n// or\\nval carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","upsert-id":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to \\"123abc\\",\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert":"val docId2 = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-composite-primary-key":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to mapOf( \\"userId\\" to \\"456abc\\", \\"workId\\" to 789),\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-datatypes":"ditto.store[\\"foo\\"].upsert(mapOf(\\n    \\"boolean\\" to true,\\n    \\"string\\" to \\"Hello World\\",\\n    \\"number\\" to 10,\\n    \\"map\\" to mapOf(\\"key\\" to \\"value\\"),\\n    \\"array\\" to listOf(1,2,3),\\n    \\"null\\" to null\\n))\\n\\n","write-transaction":"val results = ditto.store.write { transaction ->\\n    val cars = transaction.scoped(\\"cars\\")\\n    val people = transaction.scoped(\\"people\\")\\n    val docId = \\"abc123\\"\\n    people.upsert(mapOf(\\"_id\\" to docId, \\"name\\" to \\"Susan\\"))\\n    cars.upsert(mapOf(\\"make\\" to \\"Hyundai\\", \\"color\\" to \\"red\\", \\"owner\\" to docId))\\n    cars.upsert(mapOf(\\"make\\" to \\"Jeep\\", \\"color\\" to \\"pink\\", \\"owner\\" to docId))\\n    people.findById(DittoDocumentId(docId)).evict()\\n}\\n\\n","counter":"val docId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"ownedCars\\" to DittoCounter()\\n))\\n\\nditto.store.collection(\\"people\\").findById(docId).update { mutableDoc ->\\n    mutableDoc!![\\"ownedCars\\"].counter!!.increment(amount = 1.0)\\n}\\n\\n","counter-upsert":"val frankId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"age\\" to 31,\\n    \\"ownedCars\\" to DittoCounter()\\n))\\n\\n","update":"ditto.store.collection(\\"people\\").findById(frankId).update { mutableDoc ->\\n    mutableDoc?.let {\\n        it[\\"age\\"].set(32)\\n        it[\\"ownedCars\\"].counter!!.increment(amount = 1.0)\\n    }\\n}\\n\\n","evict":"ditto.store[\\"people\\"].find(\\"age <= 32\\").evict()\\n\\n","upsert-default-data":"val docId = ditto.store.collection(\\"people\\").upsert(mapOf(\\n    \\"name\\" to \\"Susan\\",\\n    \\"age\\" to 31\\n), DittoWriteStrategy.InsertDefaultIfAbsent)\\n\\n","array-to-map":"collection.findById(docId).update { mutableDoc ->\\n    val map = mutableMapOf<String, Any>()\\n    val names = mutableDoc!![\\"friends\\"].listValue\\n    names.forEach { name ->\\n        val id = UUID.randomUUID().toString()\\n        map[id] = mapOf(\\n            \\"id\\" to id,\\n            \\"name\\" to name\\n        )\\n    }\\n\\n    mutableDoc[\\"friendsMap\\"].set(map)\\n}\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\"\\nditto.startSync()\\nval observer = ditto.presence.observe { presenceGraph ->\\n    // render peer list\\n}\\n\\n","query-basic":"val results = ditto.store.collection(\\"people\\")\\n    .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"val foundDocs = ditto.store.collection(\\"people\\")\\n    .find(\\"name == \\\\$args.name && age <= \\\\$args.age\\", mapOf(\\"name\\" to \\"max\\", \\"age\\" to 32))\\n\\n","query-sort":"val sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .exec()\\n\\n","query-limit":"val sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-basic":"try {\\n    ditto.startSync()\\n}\\ncatch (e: DittoError) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- DittoRegister live query to update UI\\nval liveQuery = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .observeLocal { docs, event ->\\n        // Do something...\\n    }\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfun userDidInsertCar() {\\n    ditto.store.collection(\\"cars\\").upsert(mapOf(\\n        \\"model\\" to \\"Ford\\",\\n        \\"color\\" to \\"black\\"\\n    ))\\n}\\n\\n// --- DittoRegister live query to update UI\\nval observeLocalQuery = ditto.store.collection(\\"cars\\")\\n    .find(\\"isSold == false\\")\\n    .observeLocal { docs, event ->\\n    // Do something...\\n}\\n\\n","subscribe":"// --- DittoRegister live query to update UI\\nval subscription = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .subscribe()\\n\\n","online-playground":"try {\\n    val androidDependencies = DefaultAndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OnlinePlayground(androidDependencies, appID = \\"00000000-0000-4000-0000-000000000000\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\")\\n    val ditto = Ditto(androidDependencies, identity)\\n    ditto.startSync()\\n} catch(e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","offline-playground":"try {\\n    val androidDependencies = AndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OfflinePlayground(androidDependencies, appId =\\n    \\"00000000-0000-4000-0000-000000000000\\")\\n    val ditto = Ditto(androidDependencies, identity)\\n    ditto.setOfflineOnlyLicenseToken(validLicense)\\n    ditto.startSync()\\n} catch(e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nval p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\nval androidDependencies = DefaultAndroidDittoDependencies(context)\\nval identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64, null)\\nval ditto = Ditto(androidDependencies, identity)\\nditto.setOfflineOnlyLicenseToken(validLicense)\\n\\n","network-remote-ditto":"val transportConfig = DittoTransportConfig()\\n\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.startSync()\\n\\n","network-listen":"val transportConfig = DittoTransportConfig()\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\nditto.startSync()\\n\\n","transport-sync-groups":"val transportConfig = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections \\ntransportConfig.enableAllPeerToPeer()\\n// 2. Set sync group to an integer between 0 and 2^32\\ntransportConfig.global.syncGroup = 1234\\nditto.startSync()\\n\\n","network-multiple-transports":"val transportConfig = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\ntransportConfig.enableAllPeerToPeer()\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.listen.tcp.enabled = true\\ntransportConfig.listen.http.enabled = false\\ntransportConfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\ntransportConfig.listen.tcp.port = 4000\\n// 3. Connect explicitly to remote devices\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.startSync()\\n\\n","network-monitor-conditions":"// ... Setting up inside an Activity\\nval androidDependencies = DefaultAndroidDittoDependencies(applicationContext)\\nval ditto = Ditto(androidDependencies, DittoIdentity.OnlinePlayground\\n(androidDependencies, appId = \\"REPLACE_WITH_APP_ID\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.callback = this\\nditto.startSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\n\\nclass MainActivity : AppCompatActivity(), DittoCallback {\\n\\n    override fun transportConditionDidChange(transportId: Long, condition: TransportCondition) {\\n        var toastText: String? = null\\n        if (condition == TransportCondition.TRANSPORT_CONDITION_BLE_DISABLED) {\\n            toastText = \\"BLE disabled\\"\\n        } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION) {\\n            toastText = \\"Permission missing for BLE\\"\\n        } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION) {\\n            toastText = \\"Permission missing for BLE\\"\\n        }\\n        toastText?.let {\\n            Handler(mainLooper).post {\\n                Toast.makeText(this, it, Toast.LENGTH_LONG).show()\\n            }\\n        }\\n    }\\n}\\n\\n","network-query-overlap-group":"// The passenger only observes orders that they created\\npassenger.store.collection(\\"orders\\")\\n    .find(\\"user_id==abc123\\")\\n    .observeLocal { docs, event ->\\n        // render passenger orders in a list UI\\n}\\n\\n// Crew member devices observe all orders that everyone created\\ncrewA.store.collection(\\"orders\\")\\n    .find(\\"status == \'OPEN\'\\")\\n    .observeLocal { docs, event ->\\n        // render all orders in a list UI\\n}\\ncrewB.store.collection(\\"orders\\")\\n    .find(\\"status == \'OPEN\'\\")\\n    .observeLocal { docs, event ->\\n        // render all orders in a list UI\\n}\\n\\nDittoExperimental.setQueryOverlapGroup(2u, crewA)\\nDittoExperimental.setQueryOverlapGroup(2u, crewB)\\n\\ncrewA.startSync()\\ncrewB.startSync()\\npassenger.startSync()\\n\\n","network-set-priority":"DittoExperimental.setPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2u, crewA)\\nDittoExperimental.setPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2u, crewB)\\n\\n","remove-id":"coll.findById(docId).remove()\\n\\n","remove-query":"val removedDocIds = coll.find(\\"make == \'Honda\'\\").remove()\\n\\n"},"java":{"attachment":"String attachmentPath = tempFile.getPath();\\nMap<String, String> metadata = new HashMap<>();\\nmetadata.put(\\"name\\", \\"my_image.png\\");\\nDittoAttachment attachment = coll.newAttachment(attachmentPath, metadata);\\ntempFile.delete();\\n\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"some\\", \\"string\\");\\ncontent.put(\\"my_attachment\\", attachment);\\nDittoDocumentId docID = coll.upsert(content);\\n\\nDittoDocument doc = coll.findById(docID).exec();\\nDittoAttachmentToken attachmentToken = doc.get(\\"my_attachment\\").getAttachmentToken();\\n\\nDittoAttachmentFetcher fetcher = coll.fetchAttachment(attachmentToken, event -> {\\n    if (event.getType() == DittoAttachmentFetchEventType.Completed) {\\n        DittoAttachment att = event.asCompleted().getAttachment();\\n        BufferedImage attachmentImage;\\n        try {\\n            attachmentImage = ImageIO.read(att.getInputStream());\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n    } else if (event.getType() == DittoAttachmentFetchEventType.Progress) {\\n        // do nothing - wait for `Completed` or `Deleted`\\n    } else {\\n    }\\n});\\n\\n\\n","datamodel":"DittoCollection carsCollection = ditto.store.collection(\\"cars\\");\\n\\n","upsert-id":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"_id\\", \\"123abc\\");\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 123abc\\n\\n","upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 507f191e810c19729de860ea\\n\\n","upsert-composite-primary-key":"Map<String, Object> _id = new HashMap<>();\\n_id.put(\\"userId\\", \\"456abc\\");\\n_id.put(\\"workId\\", 789);\\n\\nMap<String, Object> value = new HashMap<>();\\nvalue.put(\\"_id\\", _id);\\nvalue.put(\\"name\\", \\"Susan\\");\\nvalue.put(\\"age\\", 31);\\nDittoDocumentId docID = ditto.store.collection(\\"people\\").upsert(value);\\n// docId=> \\"_id.put(\\"userId\\", \\"456abc\\"); _id.put(\\"workId\\", 789);\\"\\n\\n","remove-id":"ditto.store.collection(\\"people\\").findById(docId).remove();\\n\\n","remove-query":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"boolean\\", true);\\ncontent.put(\\"string\\", \\"Hello World\\");\\ncontent.put(\\"number\\", 10);\\nMap<String, String> innerMap = new HashMap<>();\\ninnerMap.put(\\"key\\", \\"value\\");\\ncontent.put(\\"map\\", innerMap);\\ncontent.put(\\"array\\", Arrays.asList(1, 2, 3));\\ncontent.put(\\"null\\", null);\\nditto.store.collection(\\"foo\\").upsert(content);\\n\\n","counter":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"ownedCars\\", new DittoCounter());\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findById(docId).update(mutDoc -> {\\n    assertThat(mutDoc).isNotNull();\\n    DittoMutableCounter counter = mutDoc.get(\\"ownedCars\\").getCounter();\\n    assertThat(counter).isNotNull();\\n    counter.increment(1);\\n});\\n\\n","array-to-map":"collection.findById(docId).update(dittoMutableDocument -> {\\n    Map<String, Object> friendsMap = new HashMap<>();\\n    List<Object> names = dittoMutableDocument.get(\\"friends\\").getListValue();\\n    names.forEach(name -> {\\n        Map<String, Object> friend = new HashMap<>();\\n        String id = UUID.randomUUID().toString();\\n        friend.put(\\"id\\", id);\\n        friend.put(\\"name\\", name);\\n        friendsMap.put(id, friend);\\n    });\\n});\\n\\n","counter-upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"age\\", 31);\\ncontent.put(\\"ownedCars\\", new DittoCounter());\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findById(docId).update(doc -> {\\n    try {\\n        doc.get(\\"age\\").set(32);\\n        doc.get(\\"ownedCars\\").getCounter().increment(1);\\n    } catch (DittoError err) {\\n        // Do something with error\\n    }\\n});\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\";\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\nditto.getPresence().observe(presenceGraph -> {\\n    // render peers\\n});\\n\\n","upsert-default-data":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store\\n        .collection(\\"people\\")\\n        .upsert(content, DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","query-basic":"List<DittoDocument> results = ditto.store.collection(\\"people\\")\\n        .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"Map<String, Object> queryArgs = new HashMap<>();\\nqueryArgs.put(\\"name\\", \\"max\\");\\nqueryArgs.put(\\"age\\", 32);\\n\\nList<DittoDocument> foundDocs = ditto.store.collection(\\"users\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", queryArgs)\\n        .exec();\\n\\n","query-sort":"List<DittoDocument> sortedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .exec();\\n\\n","query-limit":"List<DittoDocument> sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- Register live query to update UI\\nDittoLiveQuery liveQuery = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .observeLocal((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","subscribe":"// --- Register live query to update UI\\nDittoSubscription subscription = ditto.store.collection(\\"cars\\")\\n        .find(\\"!isSold\\")\\n        .subscribe();\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"model\\", \\"Ford\\");\\ncontent.put(\\"color\\", \\"black\\");\\nditto.store.collection(\\"cars\\").upsert(content);\\n\\n// --- Register live query to update UI\\nDittoLiveQuery liveQueryLocal = ditto.store.collection(\\"cars\\")\\n        .find(\\"owner == \'Susan\'\\")\\n        .observeLocal((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nString p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.SharedKey(androidDependencies, \\"app\\", p256DerB64);\\nDitto ditto = new Ditto(androidDependencies, identity);\\ntry {\\n    ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","online-playground":"DittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.OnlinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\", \\"YOUR_PLAYGROUND_TOKEN_HERE\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","offline-playground":"DittoIdentity identity = new DittoIdentity.OfflinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\ntry {\\n    ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch(DittoError e) {\\n    //handle error\\n}\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","network-remote-ditto":"DittoTransportConfig config = new DittoTransportConfig();\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-listen":"DittoTransportConfig config = new DittoTransportConfig();\\nconfig.enableAllPeerToPeer();\\n\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-multiple-transports":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n// 1. Enable Peer to Peer Connections\\nconfig.enableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n// 3. Connect explicitly to remote devices\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","transport-sync-groups":"DittoTransportConfig config = new DittoTransportConfig();\\n// 1. Enable All Peer to Peer Connections\\nconfig.enableAllPeerToPeer();\\n// 2. Set sync group to an integer between 0 and 2^32\\nconfig.getGlobal().setSyncGroup(1234);\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-monitor-conditions":"// Setting up inside an Activity\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(getApplicationContext());\\nDitto ditto = new Ditto(androidDependencies, new DittoIdentity.OnlinePlayground(androidDependenciesOne, \\"REPLACE_WITH_APP_ID\\"));\\nditto.callback = this;\\nditto.startSync();\\n\\n// Now you can observe real time changes to the transport conditions:\\npublic class MainActivity extends AppCompatActivity implements DittoCallback {\\n    @Override\\n    public void transportConditionDidChange(@NotNull DittoTransportCondition condition, @NotNull DittoConditionSource transportId) {\\n        String toastText = null;\\n        if (condition == DittoTransportCondition.BleDisabled) {\\n            toastText = \\"BLE disabled\\";\\n        } else if (condition == DittoTransportCondition.NoBleCentralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        } else if (condition == DittoTransportCondition.NoBlePeripheralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        }\\n\\n        if (toastText != null) {\\n            String finalToastText = toastText;\\n            runOnUiThread(new Runnable() {\\n                @Override\\n                public void run() {\\n                    Toast.makeText(MainActivity.this, finalToastText, Toast.LENGTH_LONG).show();\\n                }\\n            });\\n        }\\n    }\\n}\\n\\n"}}');var a=n(99013),s=n(49366),c=n(30547);function l(e){let t,{name:n,language:r,label:s}=e,c=i[r];if(c){let e=c[n];e&&(t=e)}return t?o.createElement(a.Z,{className:r},t.trim().replace("00000000-0000-4000-0000-000000000000","REPLACE_ME_WITH_YOUR_APP_ID")):(console.error(`no snippet for ${n} in language=${r}`),o.createElement("div",null,"Not supported by ",s,"."))}function d(e){let{children:t,name:n}=e;const{tabGroupChoices:i,setTabGroupChoices:a}=(0,r.Z)(),d=i.platform,p=(e=>{let t=[{label:"JavaScript",value:"javascript"},{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"},{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"},{label:"C#",value:"csharp"},{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"http"}];switch(e){case"android":t=[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}];break;case"ios":t=[{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"}];break;case"raspberrypi":t=[{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"http"}];case void 0:break;default:t=t.filter((t=>t.value===e))}return t})(d),u=p[0];return o.createElement(s.Z,{platform:d,groupId:"programming-language",defaultValue:u?u.value:"swift",values:p},p.map((e=>o.createElement(c.Z,{key:`${e.value}-${n}`,value:e.value},o.createElement(l,{name:n,language:e.value,label:e.label})))))}},99013:(e,t,n)=>{"use strict";n.d(t,{Z:()=>T});var o=n(87462),r=n(67294),i=n(86010),a=n(23746),s=n(10195),c=n(87594),l=n.n(c),d=n(95999),p=n(68793),u=n(62435),m=n(71418);const y="codeBlockContainer_EiTO",g="codeBlockContent_X2I6",h="codeBlockTitle_PQMO",f="codeBlock_UxnK",v="copyButton_V-PD",D="codeBlockLines_W6UD";var b=n(32822);const w=/{([\d,-]+)}/,I=["js","jsBlock","jsx","python","html"],A={js:{start:"\\/\\/",end:""},jsBlock:{start:"\\/\\*",end:"\\*\\/"},jsx:{start:"\\{\\s*\\/\\*",end:"\\*\\/\\s*\\}"},python:{start:"#",end:""},html:{start:"\x3c!--",end:"--\x3e"}},C=["highlight-next-line","highlight-start","highlight-end"],_=function(e){void 0===e&&(e=I);const t=e.map((e=>{const{start:t,end:n}=A[e];return`(?:${t}\\s*(${C.join("|")})\\s*${n})`})).join("|");return new RegExp(`^\\s*(?:${t})\\s*$`)};function T(e){let{children:t,className:n,metastring:c,title:I}=e;const{prism:A}=(0,b.LU)(),[C,T]=(0,r.useState)(!1),[k,S]=(0,r.useState)(!1);(0,r.useEffect)((()=>{S(!0)}),[]);const E=(0,b.bc)(c)||I,L=(0,r.useRef)(null);let N=[];const O=Array.isArray(t)?t.join(""):t;if(c&&w.test(c)){const e=c.match(w)[1];N=l()(e).filter((e=>e>0))}let P=n?.replace(/language-/,"");!P&&A.defaultLanguage&&(P=A.defaultLanguage);let x=O.replace(/\n$/,"");if(0===N.length&&void 0!==P){let e="";const t=(e=>{switch(e){case"js":case"javascript":case"ts":case"typescript":return _(["js","jsBlock"]);case"jsx":case"tsx":return _(["js","jsBlock","jsx"]);case"html":return _(["js","jsBlock","html"]);case"python":case"py":return _(["python"]);default:return _()}})(P),n=O.replace(/\n$/,"").split("\n");let o;for(let r=0;r<n.length;){const i=r+1,a=n[r].match(t);if(null!==a){switch(a.slice(1).reduce(((e,t)=>e||t),void 0)){case"highlight-next-line":e+=`${i},`;break;case"highlight-start":o=i;break;case"highlight-end":e+=`${o}-${i-1},`}n.splice(r,1)}else r+=1}N=l()(e),x=n.join("\n")}const B=()=>{(0,s.Z)(x),T(!0),setTimeout((()=>T(!1)),2e3)};return r.createElement(a.ZP,(0,o.Z)({},a.lG,{key:String(k),theme:m.Z,code:x,language:P}),(e=>{let{className:t,style:n,tokens:a,getLineProps:s,getTokenProps:c}=e;return r.createElement("div",{className:y},E&&r.createElement("div",{style:n,className:h},E),r.createElement("div",{className:(0,i.Z)(g,P)},r.createElement("pre",{tabIndex:0,className:(0,i.Z)(t,f,"thin-scrollbar")},r.createElement("code",{className:D},a.map(((e,t)=>{1===e.length&&""===e[0].content&&(e[0].content="\n");const n=s({line:e,key:t}),a=N.includes(t+1);N.includes(t+1)&&(n.className+="bg-gray-800 docusaurus-highlight-code-line");let l=(0,i.Z)(n.className,a&&"bg-gray-700");return r.createElement("span",(0,o.Z)({key:t},n,{className:l}),e.map(((e,t)=>{let n={...c({token:e,key:t})},a=n.className;return a.includes("inserted-sign")&&(a=(0,i.Z)(a,"bg-green-900")),a.includes("deleted-sign")&&(a=(0,i.Z)(a,"bg-red-900")),r.createElement("span",(0,o.Z)({key:t},n,{className:a}))})))})))),r.createElement("button",{ref:L,type:"button","aria-label":(0,d.I)({id:"theme.CodeBlock.copyButtonAriaLabel",message:"Copy code to clipboard",description:"The ARIA label for copy code blocks button"}),className:(0,i.Z)(v,"clean-btn",C?"bg-green-500":""),onClick:B},C?r.createElement("div",null,r.createElement(p.Z,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copied")):r.createElement("div",null,r.createElement(u.Z,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copy")))))}))}},30547:(e,t,n)=>{"use strict";n.d(t,{Z:()=>r});var o=n(67294);const r=function(e){let{children:t,hidden:n,className:r}=e;return o.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},49366:(e,t,n)=>{"use strict";n.d(t,{Z:()=>a});var o=n(67294),r=n(80944),i=n(86010);const a=function(e){const{lazy:t,platform:n,block:a,defaultValue:s,values:c,groupId:l,className:d}=e,p=o.Children.toArray(e.children),u=c??p.map((e=>({value:e.props.value,label:e.props.label}))),m=s??p.find((e=>e.props.default))?.props.value,{tabGroupChoices:y,setTabGroupChoices:g}=(0,r.Z)(),[h,f]=(0,o.useState)(m);(0,o.useEffect)((()=>{if(null!=l){const e=y[l];null!=e&&e!==h&&(u.some((t=>t.value===e))?f(e):f(m))}}),[n,y[l]]);const v=e=>{f(e),null!=l&&g(l,e)},D=u.length>1;return o.createElement("div",{className:"tabs-container"},D&&o.createElement(o.Fragment,null,o.createElement("div",{className:"sm:hidden"},o.createElement("label",{htmlFor:"tabs",className:"sr-only"},"Select a tab"),o.createElement("select",{id:"tabs",name:"tabs",value:h,onChange:e=>v(e.currentTarget.value),className:"block w-full focus:ring-blue-500 focus:border-blue-500 border-gray-300 rounded-md"},u.map((e=>{let{value:t,label:n}=e;return o.createElement("option",{value:t,key:t},n??t)})))),o.createElement("div",{className:"hidden sm:block"},o.createElement("nav",{className:"flex space-x-4","aria-label":"Tabs"},u.map((e=>{let{value:t,label:n}=e;return o.createElement("button",{key:t,onClick:()=>v(t),className:(0,i.Z)(h===t?"bg-blue-100 text-blue-700":"text-gray-500 hover:text-gray-700","px-3 py-2 font-medium text-sm rounded-md"),"aria-current":h===t?"page":void 0},n??t)}))))),t?(0,o.cloneElement)(p.filter((e=>e.props.value===h))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},p.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==h})))))}},24959:(e,t,n)=>{"use strict";n.r(t),n.d(t,{contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var o=n(87462),r=(n(67294),n(3905)),i=(n(78561),n(49366),n(30547),n(36438));const a={title:"Syncing",sidebar_position:5},s=void 0,c={unversionedId:"concepts/syncing-data",id:"concepts/syncing-data",isDocsHomePage:!1,title:"Syncing",description:"How Does Ditto Sync Data?",source:"@site/docs/common/concepts/syncing-data.mdx",sourceDirName:"concepts",slug:"/concepts/syncing-data",permalink:"/common/concepts/syncing-data",editUrl:"https://github.com/getditto/docs/edit/main/docs/common/concepts/syncing-data.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Syncing",sidebar_position:5},sidebar:"defaultSidebar",previous:{title:"Querying",permalink:"/common/concepts/querying"},next:{title:"Removing",permalink:"/common/concepts/remove"}},l=[{value:"How Does Ditto Sync Data?",id:"how-does-ditto-sync-data",children:[],level:2},{value:"Multi-hop replication",id:"multi-hop-replication",children:[],level:2},{value:"Sync",id:"sync",children:[{value:"Subscribe",id:"subscribe",children:[],level:3},{value:"Observe",id:"observe",children:[],level:3},{value:"Sync only relevant documents",id:"sync-only-relevant-documents",children:[],level:3}],level:2},{value:"Eviction",id:"eviction",children:[],level:2},{value:"Examples",id:"examples",children:[{value:"1: Time-based syncing",id:"1-time-based-syncing",children:[],level:3},{value:"2. Stateful syncing",id:"2-stateful-syncing",children:[],level:3}],level:2}],d={toc:l};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,o.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"how-does-ditto-sync-data"},"How Does Ditto Sync Data?"),(0,r.kt)("p",null,"In this narrated video, take a glimpse under the hood of Ditto's unique sync process. This video will\nexplain how Ditto utilizes multiple transports at once to efficiently sync data with or even without the\ninternet, as well as the strengths and limitations of each transport that come together to form what we call the ",(0,r.kt)("strong",{parentName:"p"},"Rainbow Connection"),". "),(0,r.kt)("div",{className:"iframe-container",align:"center"},(0,r.kt)("iframe",{className:"responsive-iframe",width:"560",height:"315",src:"https://www.youtube.com/embed/8_A1CkYfzoM",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),(0,r.kt)("p",null,"By default, Ditto will not sync data with other devices.  When the device is\nobserving a query, it requests to synchronize data that matches the query from\nother devices in the mesh network. "),(0,r.kt)("p",null,"In other words, when a live query is created, Ditto's sync system\n",(0,r.kt)("strong",{parentName:"p"},"pulls"),' data from other devices. There is no way to "push" data through the\nAPI explicitly. Devices select data they are interested in through the query\nsystem and then synchronize with the mesh network based on that query.'),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Query-based Subscriptions",src:n(28546).Z})),(0,r.kt)("h2",{id:"multi-hop-replication"},"Multi-hop replication"),(0,r.kt)("p",null,'Given that Ditto works peer-to-peer, devices can form into arbitrary groups\nbased on the proximity to one another, or rather they create an ad-hoc mesh\nnetwork. Ditto\'s sync system allows for devices to share data through another\ndevice, called "multi-hop" sync. The only requirement for this to occur is that\nall devices in the chain must be observing the same data, as shown below:'),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Multi-hop Subscriptions",src:n(51915).Z})),(0,r.kt)("h2",{id:"sync"},"Sync"),(0,r.kt)("p",null,"The small peer uses a selfish, query-based syncronization protocol. That means\neach device needs to explicitly tell other peers what data to sync using a query. Each peer also must explicitly opt-in to\nstart syncronizing data. "),(0,r.kt)("p",null,"Preferably, you should tell ditto to start synchronizing early on in your application's life cycle like in your ",(0,r.kt)("inlineCode",{parentName:"p"},"AppDelegate.application(_:didFinishLaunchingWithOptions:)")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Application.onCreate")," method. Your application only needs to call this function once."),(0,r.kt)(i.Z,{name:"sync-basic",mdxType:"SnippetGroup"}),(0,r.kt)("h3",{id:"subscribe"},"Subscribe"),(0,r.kt)("p",null,"Creating a subscription acts as a signal to other peers that you are interested in\nreceiving updates when local or remote changes are made to\ndocuments that match the given query. "),(0,r.kt)("p",null,"The returned Subscription object must be kept in scope for as long as\nyou want to keep receiving updates. This function is useful if you're\ninterested in subscribing to changes on a query to have a local offline copy of\nthe data."),(0,r.kt)(i.Z,{name:"subscribe",mdxType:"SnippetGroup"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Call ",(0,r.kt)("inlineCode",{parentName:"li"},".subscribe")," after ",(0,r.kt)("inlineCode",{parentName:"li"},"ditto.startSync()")," to synchronize and download real-time data from other peers."),(0,r.kt)("li",{parentName:"ul"},"To manually stop the ",(0,r.kt)("inlineCode",{parentName:"li"},"liveQuery"),", set it either to ",(0,r.kt)("inlineCode",{parentName:"li"},"null"),", drop the variable, or call ",(0,r.kt)("inlineCode",{parentName:"li"},"liveQuery.stop()"),".")),(0,r.kt)("h3",{id:"observe"},"Observe"),(0,r.kt)("p",null,"Create a query to get notified when the database gets new changes. The returned\nLiveQuery object must be kept in scope for as long as you want to keep receiving\nupdates. ",(0,r.kt)("a",{parentName:"p",href:"./querying"},"Learn more about how to create queries")),(0,r.kt)(i.Z,{name:"sync-observe-local",mdxType:"SnippetGroup"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Call ",(0,r.kt)("inlineCode",{parentName:"li"},".observeLocal")," to observe real-time data from your local database."),(0,r.kt)("li",{parentName:"ul"},"The callback will immediately run for documents that fit the query."),(0,r.kt)("li",{parentName:"ul"},"The callback will get called with all local changes that fit the query. "),(0,r.kt)("li",{parentName:"ul"},"The callback will get called for each sync or write transaction.")),(0,r.kt)("h3",{id:"sync-only-relevant-documents"},"Sync only relevant documents"),(0,r.kt)("p",null,"To reduce memory and disk usage over time, ",(0,r.kt)("em",{parentName:"p"},"ONLY")," sync documents that are relevant for a given device at a\ngiven time. There are various approaches to this problem, and it depends on your application."),(0,r.kt)("p",null,"For example, if you are building a meal ordering application, you may want to\nonly synchronize all orders that have been created in the past 24 hours. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'ditto.store.collection("orders").find("createdAt > $args.yesterday", args: [\n  "yesterday": Date().adding(hr:-24),\n]).observeLocal({ cars, event in\n     // do something\n})\n')),(0,r.kt)("p",null,"If there are 2,000 orders per day, you would see 2,000 documents\nlocally on the device. If each document is 50Kb, the device could\nreplicate up to ~100 megabytes to the local database. "),(0,r.kt)("h2",{id:"eviction"},"Eviction"),(0,r.kt)("p",null,"When you subscribe to data that is relevant, you need to remove it from the\nlocal device once it is no longer relevant. You want to remove data from the\nlocal database ",(0,r.kt)("em",{parentName:"p"},"without")," deleting that data on other devices. "),(0,r.kt)("p",null,"This operation is different than remove in that it only removes one or more\ndocuments from the local storage and ",(0,r.kt)("strong",{parentName:"p"},"does not sync the change to other\ndevices.")),(0,r.kt)(i.Z,{name:"evict",mdxType:"SnippetGroup"}),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("h3",{id:"1-time-based-syncing"},"1: Time-based syncing"),(0,r.kt)("p",null,"One common design pattern is to only synchronize data that was written within the\npast 24 hours. At the end of that 24 hours, documents older than 24 hours are evicted and a\nnew query is created."),(0,r.kt)("p",null,"Let's look through a typical example for syncing data: four flight attendants walk\nthrough an airlane and record passenger meal orders on their tablets. "),(0,r.kt)("p",null,"The database has a ",(0,r.kt)("inlineCode",{parentName:"p"},"flights")," collection, with each flight represented as a\ndocument. Each document has a ",(0,r.kt)("inlineCode",{parentName:"p"},"createdAt")," timestamp."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "createdAt": "2022-09-17T20:00:46.945Z",\n  "flightNo": "DIT101",\n  "orders": {\n    "abcdef123": {\n      ...\n    }\n  }\n}\n')),(0,r.kt)("p",null,"We want to only store data on the device that was created in the past 24 hours.\nAnything older than 24 hours should be removed locally from the device. However,\nwe don't want to remove this data from the entire mesh network, because we may\nwant to do analytics on it later using the Big Peer. So, we do not use remove()\nbecause that deletes data from the entire network, including the Cloud. We use\n",(0,r.kt)("inlineCode",{parentName:"p"},"evict()")," to remove data from the local device because the data is not relevant\nanymore."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'ditto.store.collection("flights").find("createdAt <= $args.yesterday", args: [\n  "yesterday": yesterday(),\n]).evict()\n')),(0,r.kt)("p",null,"One way to implement eviction would be to create a global interval. For example,\nevery 4 hours check to see if there is any data on the local machine that is\nirrelevant. If so, evict it."),(0,r.kt)("p",null,"Devices should periodically restart the query with a new date. Notice that the\nquery for eviction is exactly the opposite as the query for subscription. These\nqueries should not overlap."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'ditto.store.collection("flights").find("createdAt > $args.yesterday", args: [\n  "yesterday": yesterday(),\n]).subscribe()\n')),(0,r.kt)("h3",{id:"2-stateful-syncing"},"2. Stateful syncing"),(0,r.kt)("p",null,"Another common design pattern is to build state into each document type. In an\nordering application, orders go through a lifecycle."),(0,r.kt)("p",null,"OPEN -> IN PROGRESS -> COMPLETE -> FILLED",(0,r.kt)("br",{parentName:"p"}),"\n","|\n-> CANCELLED"),(0,r.kt)("p",null,"When the application starts, the device only wants to synchronize orders that are not\nfilled or cancelled, and evict any orders that have been completed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},"self.query =  self.ditto.collection(\"orders\")\n  .find(\"status != 'FILLED' && status != 'CANCELLED'\")\n  .subscribe()\nself.ditto.collection(\"orders\").find(\"status == 'FILLED' || status == 'CANCELLED'\").evict()\n")),(0,r.kt)("p",null,"Once an order has been completed, document as \u201cFILLED\u201d. Live queries will fire and update the front-page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'self.ditto.collection("orders").upsert([\n  "_id": id,\n  "status": "FILLED"\n])\n')),(0,r.kt)("p",null,"An order could also become cancelled whlie it was unfilled. A cancelled order is\nbased on the business logic -- for example, an order could be cancelled\nmanually, or cancelled when the store closes, or because the order was placed\nmore than 24 hours prior. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-swift"},'self.ditto.collection("orders").upsert([\n  "_id": id,\n  "status": "CANCELLED"\n])\nself.ditto.collection("orders").findByID(id).evict()\n')))}p.isMDXComponent=!0},11748:(e,t,n)=>{var o={"./locale":89234,"./locale.js":89234};function r(e){var t=i(e);return n(t)}function i(e){if(!n.o(o,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return o[e]}r.keys=function(){return Object.keys(o)},r.resolve=i,e.exports=r,r.id=11748},87594:(e,t)=>{function n(e){let t,n=[];for(let o of e.split(",").map((e=>e.trim())))if(/^-?\d+$/.test(o))n.push(parseInt(o,10));else if(t=o.match(/^(-?\d+)(-|\.\.\.?|\u2025|\u2026|\u22EF)(-?\d+)$/)){let[e,o,r,i]=t;if(o&&i){o=parseInt(o),i=parseInt(i);const e=o<i?1:-1;"-"!==r&&".."!==r&&"\u2025"!==r||(i+=e);for(let t=o;t!==i;t+=e)n.push(t)}}return n}t.default=n,e.exports=n},23746:(e,t,n)=>{"use strict";n.d(t,{ZP:()=>y,lG:()=>a});var o=n(87410);const r={plain:{backgroundColor:"#2a2734",color:"#9a86fd"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#6c6783"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#e09142"}},{types:["property","function"],style:{color:"#9a86fd"}},{types:["tag-id","selector","atrule-id"],style:{color:"#eeebff"}},{types:["attr-name"],style:{color:"#c4b9fe"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","atrule","placeholder","variable"],style:{color:"#ffcc99"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#c4b9fe"}}]};var i=n(67294),a={Prism:o.default,theme:r};function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(){return c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},c.apply(this,arguments)}var l=/\r\n|\r|\n/,d=function(e){0===e.length?e.push({types:["plain"],content:"\n",empty:!0}):1===e.length&&""===e[0].content&&(e[0].content="\n",e[0].empty=!0)},p=function(e,t){var n=e.length;return n>0&&e[n-1]===t?e:e.concat(t)},u=function(e,t){var n=e.plain,o=Object.create(null),r=e.styles.reduce((function(e,n){var o=n.languages,r=n.style;return o&&!o.includes(t)||n.types.forEach((function(t){var n=c({},e[t],r);e[t]=n})),e}),o);return r.root=n,r.plain=c({},n,{backgroundColor:null}),r};function m(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&-1===t.indexOf(o)&&(n[o]=e[o]);return n}const y=function(e){function t(){for(var t=this,n=[],o=arguments.length;o--;)n[o]=arguments[o];e.apply(this,n),s(this,"getThemeDict",(function(e){if(void 0!==t.themeDict&&e.theme===t.prevTheme&&e.language===t.prevLanguage)return t.themeDict;t.prevTheme=e.theme,t.prevLanguage=e.language;var n=e.theme?u(e.theme,e.language):void 0;return t.themeDict=n})),s(this,"getLineProps",(function(e){var n=e.key,o=e.className,r=e.style,i=c({},m(e,["key","className","style","line"]),{className:"token-line",style:void 0,key:void 0}),a=t.getThemeDict(t.props);return void 0!==a&&(i.style=a.plain),void 0!==r&&(i.style=void 0!==i.style?c({},i.style,r):r),void 0!==n&&(i.key=n),o&&(i.className+=" "+o),i})),s(this,"getStyleForToken",(function(e){var n=e.types,o=e.empty,r=n.length,i=t.getThemeDict(t.props);if(void 0!==i){if(1===r&&"plain"===n[0])return o?{display:"inline-block"}:void 0;if(1===r&&!o)return i[n[0]];var a=o?{display:"inline-block"}:{},s=n.map((function(e){return i[e]}));return Object.assign.apply(Object,[a].concat(s))}})),s(this,"getTokenProps",(function(e){var n=e.key,o=e.className,r=e.style,i=e.token,a=c({},m(e,["key","className","style","token"]),{className:"token "+i.types.join(" "),children:i.content,style:t.getStyleForToken(i),key:void 0});return void 0!==r&&(a.style=void 0!==a.style?c({},a.style,r):r),void 0!==n&&(a.key=n),o&&(a.className+=" "+o),a})),s(this,"tokenize",(function(e,t,n,o){var r={code:t,grammar:n,language:o,tokens:[]};e.hooks.run("before-tokenize",r);var i=r.tokens=e.tokenize(r.code,r.grammar,r.language);return e.hooks.run("after-tokenize",r),i}))}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(){var e=this.props,t=e.Prism,n=e.language,o=e.code,r=e.children,i=this.getThemeDict(this.props),a=t.languages[n];return r({tokens:function(e){for(var t=[[]],n=[e],o=[0],r=[e.length],i=0,a=0,s=[],c=[s];a>-1;){for(;(i=o[a]++)<r[a];){var u=void 0,m=t[a],y=n[a][i];if("string"==typeof y?(m=a>0?m:["plain"],u=y):(m=p(m,y.type),y.alias&&(m=p(m,y.alias)),u=y.content),"string"==typeof u){var g=u.split(l),h=g.length;s.push({types:m,content:g[0]});for(var f=1;f<h;f++)d(s),c.push(s=[]),s.push({types:m,content:g[f]})}else a++,t.push(m),n.push(u),o.push(0),r.push(u.length)}a--,t.pop(),n.pop(),o.pop(),r.pop()}return d(s),c}(void 0!==a?this.tokenize(t,o,a,n):[o]),className:"prism-code language-"+n,style:void 0!==i?i.root:{},getLineProps:this.getLineProps,getTokenProps:this.getTokenProps})},t}(i.Component)},71418:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});const o={plain:{color:"#9CDCFE",backgroundColor:"#1E1E1E"},styles:[{types:["prolog"],style:{color:"rgb(0, 0, 128)"}},{types:["comment"],style:{color:"rgb(106, 153, 85)"}},{types:["builtin","changed","keyword","interpolation-punctuation"],style:{color:"rgb(86, 156, 214)"}},{types:["number","inserted"],style:{color:"rgb(181, 206, 168)"}},{types:["constant"],style:{color:"rgb(100, 102, 149)"}},{types:["attr-name","variable"],style:{color:"rgb(156, 220, 254)"}},{types:["deleted","string","attr-value","template-punctuation"],style:{color:"rgb(206, 145, 120)"}},{types:["selector"],style:{color:"rgb(215, 186, 125)"}},{types:["tag"],style:{color:"rgb(78, 201, 176)"}},{types:["tag"],languages:["markup"],style:{color:"rgb(86, 156, 214)"}},{types:["punctuation","operator"],style:{color:"rgb(212, 212, 212)"}},{types:["punctuation"],languages:["markup"],style:{color:"#808080"}},{types:["function"],style:{color:"rgb(220, 220, 170)"}},{types:["class-name"],style:{color:"rgb(78, 201, 176)"}},{types:["char"],style:{color:"rgb(209, 105, 105)"}}]}},28546:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});const o=n.p+"assets/images/syncing_data_1_subscribe-958b49e82de5018d49fae57ac93925f1.jpg"},51915:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});const o=n.p+"assets/images/syncing_data_2_same_sub-309b98b7750c17ec49945f1b5e8d8b77.jpg"},68793:(e,t,n)=>{"use strict";n.d(t,{Z:()=>r});var o=n(67294);const r=o.forwardRef((function(e,t){return o.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:2,stroke:"currentColor","aria-hidden":"true",ref:t},e),o.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"}))}))},62435:(e,t,n)=>{"use strict";n.d(t,{Z:()=>r});var o=n(67294);const r=o.forwardRef((function(e,t){return o.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:2,stroke:"currentColor","aria-hidden":"true",ref:t},e),o.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"}))}))},10195:(e,t,n)=>{"use strict";function o(e,t){let{target:n=document.body}=void 0===t?{}:t;const o=document.createElement("textarea"),r=document.activeElement;o.value=e,o.setAttribute("readonly",""),o.style.contain="strict",o.style.position="absolute",o.style.left="-9999px",o.style.fontSize="12pt";const i=document.getSelection();let a=!1;i.rangeCount>0&&(a=i.getRangeAt(0)),n.append(o),o.select(),o.selectionStart=0,o.selectionEnd=e.length;let s=!1;try{s=document.execCommand("copy")}catch{}return o.remove(),a&&(i.removeAllRanges(),i.addRange(a)),r&&r.focus(),s}n.d(t,{Z:()=>o})}}]);
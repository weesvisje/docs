"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6221],{36438:function(n,t,e){e.d(t,{p:function(){return l},Z:function(){return d}});var o=e(67294),r=e(80944),i=JSON.parse('{"rust":{"remove-query":"let removed_ids = col_tx\\n    .find_with_args(\\"color == $args.color\\", json!({\\"color\\": \\"yellow\\"}))\\n    .remove()\\n    .unwrap();\\n\\n","evict":"let evicted_ids = collection\\n    .find_with_args(\\"$args.color == color\\", json!({\\"color\\": \\"red\\"}))\\n    .sort(vec![sort_param])\\n    .evict()\\n    .unwrap();\\n\\n","sync-basic":"let res = ditto.start_sync();\\n\\n","datamodel":"let store = ditto.store();\\nlet collection = store.collection(\\"people\\").unwrap();\\n\\n","upsert-id":"let doc_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet person = json!({ // Person implements serde::Serialize\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(person).unwrap();\\n\\n","upsert":"let person = json!({\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\nlet collection = ditto.store().collection(\\"people\\").unwrap();\\nlet id = collection.upsert(person).unwrap();\\n\\n","remove-id":"collection.find_by_id(id).remove().unwrap();\\n\\n","upsert-composite-primary-key":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet complex_id = PersonId {\\n    user_id: \\"456abc\\".to_string(),\\n    work_id: 789,\\n};\\nlet doc_id = DocumentId::new(&serde_json::json!(complex_id)).unwrap();\\nlet doc = json!({\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(doc).unwrap();\\n\\n","upsert-datatypes":"collection\\n    .upsert(json!({\\n      \\"boolean\\": true,\\n      \\"string\\": \\"Hello World\\",\\n      \\"number\\": 10,\\n      \\"map\\": {\\n        \\"key\\": \\"value\\"\\n      },\\n      \\"array\\": [1,2,3],\\n      \\"null\\": null,\\n    }))\\n    .unwrap();\\n\\n","upsert-default-data":"let default_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet data = json!({ // Person implements serde::Serialize\\n    \\"_id\\": default_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection\\n    .upsert_with_strategy(data, WriteStrategy::InsertDefaultIfAbsent)\\n    .unwrap();\\n\\n","attachment":"let store = ditto.store();\\nlet collection = store.collection(\\"foo\\")?;\\nlet attachment_file_path = images_dir.join(\\"image.png\\");\\nlet mut metadata = HashMap::new();\\nmetadata.insert(\\"some\\".to_owned(), \\"string\\".to_owned());\\nlet attachment =\\n    collection.new_attachment(attachment_file_path.to_str().unwrap(), metadata)?;\\nlet doc_id = DocumentId::new(&\\"123abc\\".to_string())?;\\nlet content = json!({\\"_id\\": doc_id, \\"some\\": \\"string\\", \\"my_attachment\\": attachment});\\nlet _ = collection.upsert(content)?;\\n// Later or on another peer ...\\nlet doc = collection.find_by_id(doc_id).exec()?;\\nlet attachment_token = doc.get::<DittoAttachmentToken>(\\"my_attachment\\")?;\\nlet (tx, rx) = channel();\\nlet m_tx = std::sync::Mutex::new(tx);\\nlet fetcher = collection.fetch_attachment(attachment_token, move |event| {\\n    // completion handler\\n    if let DittoAttachmentFetchEvent::Completed { attachment } = event {\\n        let tx = m_tx.lock().unwrap();\\n        tx.send(attachment).unwrap();\\n    }\\n})?;\\nlet fetched_attachment = rx.recv().unwrap(); // may also use an async version or other sync strategy\\nlet attachment_file_path = fetched_attachment.path();\\nstd::fs::read(attachment_file_path)?;\\n\\n","counter":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": 0}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|x| {\\n        if let Some(doc) = x {\\n            doc.set(\\"owned_cars\\", DittoCounter::new()).unwrap();\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","update":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": 0}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            doc.set(\\"age\\", 32).unwrap();\\n            doc.set(\\"owned_cars\\", DittoCounter::new()).unwrap();\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","query-basic":"collection\\n    .find(\\"favoriteBook.title == \\\\\'The Great Gatsby\\\\\'\\")\\n    .exec()?;\\n\\n","query-args":"let args = json!({\\"name\\": \\"Susan\\", \\"age\\": 32});\\ncollection\\n    .find_with_args(\\"name == $args.name && arg <= $args.age\\", args)\\n    .exec()?;\\n\\n","query-sort":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"miles\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .exec()?;\\n\\n","query-limit":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"rank\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .limit(100)\\n    .exec()?;\\n\\n","subscribe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet live_query = store\\n    .collection(\\"cars\\")?\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .subscribe();\\n\\n","sync-observe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet (tx, rx) = channel();\\n{\\n    let live_query = store.collection(\\"cars\\")?.find(\\"color == \\\\\'red\\\\\'\\").observe(\\n        move |mut docs: Vec<BoxedDocument>, event| {\\n            match event {\\n                LiveQueryEvent::Initial { .. } => { /* handle if appropriate */ }\\n                LiveQueryEvent::Update { mut insertions, .. } => {\\n                    insertions.sort_by(|a, b| b.cmp(a));\\n                    for idx in insertions.iter() {\\n                        let doc = docs.remove(*idx);\\n                        let _ = tx.send(doc).unwrap();\\n                    }\\n                }\\n            }\\n        },\\n    )?;\\n    store\\n        .collection(\\"cars\\")?\\n        .upsert(json!({\\"color\\": \\"red\\"}))\\n        .unwrap();\\n    for doc in rx.iter() {\\n        println!(\\"New doc {:?}\\", doc);\\n    }\\n} // IMPORTANT: LiveQuery goes out of scope and is Dropped and terminated here.\\n\\n","sync-observe-local":"// Some action in your app ...\\nlet store = ditto.store();\\nstore.collection(\\"cars\\")?.upsert(json!({\\"color\\": \\"red\\"}))?;\\n// Elsewhere register handlers for data changes\\n{\\n    let live_query = store\\n        .collection(\\"cars\\")?\\n        .find(\\"color == \\\\\'red\\\\\'\\")\\n        .observe_local(move |cars, event| {\\n            println!(\\"cars {:?}, event {:?}\\", cars, event);\\n            // do something when data changes\\n            // BUT this closure must be permitted to take ownership\\n        })?;\\n    // stash your live query in something with a long lifetime\\n    // or it will be dropped\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nlet p256_der_b64: &str = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nlet app_id = AppId::from_env(\\"app\\")?;\\nlet ditto = Ditto::builder()\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| identity::SharedKey::new(ditto_root, app_id, p256_der_b64))?\\n    .with_minimum_log_level(CLogLevel::Info)\\n    .build()?;\\nlet res = ditto.set_offline_only_license_token(&license_token);\\nditto.start_sync()?;\\n\\n","online-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        let shared_token = std::env::var(\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\").unwrap();\\n        let enable_cloud_sync = true;\\n        let custom_auth_url = None;\\n        OnlinePlayground::new(\\n            ditto_root,\\n            app_id,\\n            shared_token,\\n            enable_cloud_sync,\\n            custom_auth_url,\\n        )\\n    })?\\n    .build()?;\\n\\nditto.start_sync()?;\\n\\n","offline-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        OfflinePlayground::new(ditto_root, app_id)\\n    })?\\n    .build()?;\\n\\nditto.start_sync()?;\\nlet res = ditto.set_offline_only_license_token(&license_token);\\n\\n","network-remote-ditto":"let mut config = TransportConfig::new(); // empty\\n\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"185.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","network-listen":"let mut config = TransportConfig::new(); // empty\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","network-multiple-transports":"let mut config = TransportConfig::new(); // empty\\n\\n// 1. Enable auto-discovery of peer to peer connections\\nconfig.enable_all_peer_to_peer(); // Auto-connect via lan and bluetooth\\n\\n// 2. Configure TCP Listener\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\n// 3. Configure explicit, hard coded connections\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n"},"objc":{"attachment":"NSBundle *testBundle = [NSBundle bundleForClass:self.class];\\nNSURL *attachmentTestImage = [testBundle URLForResource:@\\"attachment_test\\" withExtension:@\\"png\\"];\\nNSData *attachmentData = [NSData dataWithContentsOfURL:attachmentTestImage];\\n\\nNSDictionary<NSString *, NSString *> *metadata = @{@\\"name\\": @\\"my_image.png\\"};\\nDITAttachment *attachment = [collection newAttachment:attachmentTestImage.path metadata:metadata];\\n\\nDITDocumentID *docID = [collection upsert:@{@\\"some\\": @\\"string\\", @\\"my_attachment\\": attachment} error:nil];\\nDITDocument *doc = [[collection findByID:docID] exec];\\nDITAttachmentToken *attachmentToken = doc[@\\"my_attachment\\"].attachmentToken;\\n\\nDITAttachmentFetcher *fetcher = [collection fetchAttachment:attachmentToken onFetchEvent:^(DITAttachmentFetchEvent *event) {\\n    switch (event.type) {\\n        case DITAttachmentFetchEventTypeCompleted: {\\n            DITAttachmentFetchEventCompleted *completed = [event asCompleted];\\n            DITAttachment *fetchedAttachment = completed.attachment;\\n            NSData *fetchedAttachmentData = [fetchedAttachment getData:nil];\\n            [attachmentRoundtripExpectation fulfill];\\n            break;\\n        }\\n        case DITAttachmentFetchEventTypeProgress:\\n            break;\\n        default:\\n            break;\\n    }\\n}];\\n\\n\\n","counter":"[[collection find:@\\"make == \'Honda\'\\"] updateWithBlock:^(NSArray<DITMutableDocument *> *docs) {\\n    for (DITMutableDocument *doc in docs) {\\n        [doc[@\\"mileage\\"] set:DITCounter.new];\\n        [doc[@\\"mileage\\"].counter incrementBy:1];\\n    }\\n}];\\n\\n","datamodel":"DITCollection *collection = [store collection:@\\"people\\"];\\n\\n","upsert-id":"DITDocumentID *docId = [collection upsert:@{@\\"_id\\": @\\"123abc\\", @\\"name\\": @\\"Susan\\", @\\"age\\": @32 } error:nil];\\nNSLog(@\\"%@\\", docId); // => \\"123abc\\"\\n\\n","upsert":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                         upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                         error:nil];\\n\\n","upsert-composite-primary-key":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                upsert:@{\\n                  @\\"_id\\": @{ @\\"userId\\": @\\"456abc\\", @\\"workId\\": @789 },\\n                  @\\"name\\": @\\"John\\",\\n                  @\\"age\\": @31 }\\n                error:nil];\\nNSLog(@\\"%@\\", docID); // => \\"NSDictionary @{ @\\"userId\\": \\"456abc\\": @\\"workId\\": @789 }\\"\\n\\n","upsert-datatypes":"[[ditto.store collection:@\\"foo\\"]\\n    upsert:@{\\n        @\\"boolean\\": @true,\\n        @\\"string\\": @\\"Hello World\\",\\n        @\\"number\\": @10,\\n        @\\"map\\": @{ @\\"key\\": @\\"value\\" },\\n        @\\"array\\": @[ @1, @2, @3 ],\\n        @\\"null\\": [NSNull null]\\n    }\\n error:nil\\n];\\n\\n","upsert-default-data":"DITDocumentID *defaultDocID = [[ditto.store collection:@\\"people\\"]\\n                               upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                               writeStrategy: DITWriteStrategyInsertDefaultIfAbsent\\n                               error:nil];\\n\\n","query-basic":"NSArray *docs = [[[ditto.store collection:@\\"people\\"]\\n                    find:@\\"favoriteBook.title == \'The Great Gatsby\'\\"] exec];\\n\\n","query-args":"NSArray *documents = [[[ditto.store collection:@\\"people\\"] find:@\\"name == $args.name && age <= $args.age\\" withArgs:@{@\\"age\\": @32, @\\"name\\": @\\"Max\\"}] exec];\\n\\n","remove-query":"NSArray<DITDocumentID *> *removedIDs = [[[ditto.store collection:@\\"people\\"]\\n                                         find:@\\"name == \'Susan\'\\"] remove];\\n\\n","remove-id":"[[[ditto.store collection:@\\"test\\"] findByID:docID] remove];\\n\\n","update":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"] upsert:@{\\n    @\\"name\\": @\\"Frank\\",\\n    @\\"age\\": [NSNumber numberWithInt:31],\\n    @\\"ownedCars\\": [NSNumber numberWithInt:0],\\n} error:nil];\\n\\n\\nDITCollection *collection = [ditto.store collection:@\\"people\\"];\\n[[collection findByID:docID] updateWithBlock:^(DITMutableDocument *doc) {\\n    [doc[@\\"age\\"] set:[NSNumber numberWithInt:32]];\\n    [doc[@\\"ownedCars\\"] set:DITCounter.new];\\n    [doc[@\\"ownedCars\\"].counter incrementBy:1];\\n}];\\n\\n","query-sort":"NSArray *sortedRedCars = [[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending] exec];\\n\\n","query-limit":"NSArray *sortedAndLimitedRedCars = [[[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending]\\n                  limit:100] exec];\\n\\n","sync-basic":"DITDitto *ditto = [TestHelpers makeDitto];\\n\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","write-transaction":"NSArray *results = [store write:^(DITWriteTransaction *tx) {\\n    DITScopedWriteTransaction *cars = tx[@\\"cars\\"];\\n    DITScopedWriteTransaction *people = tx[@\\"people\\"];\\n    DITDocumentID *docID = [[DITDocumentID alloc] initWithValue: @\\"abc123\\"];\\n    [people upsert:@{@\\"_id\\": docID, @\\"name\\": @\\"Susan\\"} error:nil];\\n    [cars upsert:@{@\\"make\\": @\\"Ford\\", @\\"color\\": @\\"black\\", @\\"owner\\": docID} error:nil];\\n    [cars upsert:@{@\\"make\\": @\\"Toyota\\", @\\"color\\": @\\"red\\", @\\"owner\\": docID} error:nil];\\n}];\\n\\nSuppressUnusedWarning(results);\\n\\n","sync-observe":"DITDitto *ditto = [TestHelpers makeDitto];\\n// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observe:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","subscribe":"DITDitto *ditto = [TestHelpers makeDitto];\\n// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITSubscription *subscription = [[collection find:@\\"color == \'red\'\\"] subscribe];\\n\\n","sync-observe-local":"DITDitto *ditto = [TestHelpers makeDitto];\\n// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\n\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\n\\nNSString *p256_der_b64 = @\\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDITIdentity *identity = [[DITIdentity alloc] initSharedKeyWithAppID:@\\"app\\" sharedKey:p256_der_b64];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\n\\nNSError *error = nil;\\nif (![ditto setOfflineOnlyLicenseToken:validLicense error:&error]) {\\n  NSLog(@\\"Error setting license: %@\\", error);\\n}\\n\\n","online-playground":"// Replace the all-zero app ID with your own app ID\\nDITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"\\n                                                                       token:@\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","offline-playground":"// Replace the all-zero app ID with your own app ID\\nDITIdentity *identity = [[DITIdentity alloc] initOfflinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nNSError *error = nil;\\nif (![ditto setOfflineOnlyLicenseToken:validLicense error:&error]) {\\n  NSLog(@\\"Error setting license: %@\\", error);\\n}\\nif (![ditto startSync:&error]) {\\n  NSLog(@\\"Error starting sync: %@\\", error);\\n}\\n[ditto startSync:&error];\\n\\n","network-remote-ditto":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-listen":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-multiple-transports":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n// 1. Enable Local Area Network Connections\\n[transportConfig enableAllPeerToPeer];\\n// 2. Listen for incoming connections on port 4000\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n// 3. Connect explicitly to remote devices\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nDITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"REPLACE_WITH_APP_ID\\" token:@\\"REPLACE_WITH_PLAYGROUND_TOKEN\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nditto.delegate = self;\\n[ditto startSync:nil];\\n \\n// Now you can observe real time changes to the transport conditions:\\n@interface ViewController () <DITDittoDelegate>\\n\\n@end\\n\\n@implementation ViewController\\n\\n- (void)transportConditionChanged:(enum DITTransportCondition)condition forSubsystem:(enum DITConditionSource)source {\\n    if (condition == DITTransportConditionBleDisabled) {\\n        NSLog(@\\"BLE disabled\\");\\n    } else if (condition == DITTransportConditionNoBleCentralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    } else if (condition == DITTransportConditionNoBlePeripheralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    }\\n}\\n\\n@end\\n\\n","network-query-overlap-group":"NSString *const orders = @\\"orders\\";\\n\\n// The passenger only observes orders that they created\\n[[[passenger.store collection:orders] find:@\\"user_id==abc123\\"] observe:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render my orders in a list UI\\n}];\\n\\n// Crew member devices observe all orders that everyone created\\n[[[crewA.store collection:orders] findAll] observe:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render all orders in a list UI\\n}];\\n\\n[[[crewB.store collection:orders] findAll] observe:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render all orders\\n}];\\n\\n// Set up our query overlap group and priorities such that the crew members\\n// will construct multihop connections with each other.\\n[DITExperimental setQueryOverlapGroup:2 ditto:crewA];\\n[DITExperimental setQueryOverlapGroup:2 ditto:crewB];\\n\\n// Query overlap groups should be set before startSync\\n[crewA startSync:nil];\\n[crewB startSync:nil];\\n[passenger startSync:nil];\\n\\n","network-set-priority":"[DITExperimental setPriority:DITConnectionPriorityHigh\\n                 forQueryOverlapGroup:2 ditto:crewA];\\n[DITExperimental setPriority:DITConnectionPriorityHigh\\n        forQueryOverlapGroup:2 ditto:crewB];\\n\\n","evict":"NSArray<DITDocumentID *> *evictedIDs = [[collection find:@\\"make == \'Honda\'\\"] evict];\\n\\n"},"swift":{"shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nlet p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\nlet identity = DittoIdentity.sharedKey(appID: \\"app\\", sharedKey: p256DerB64)\\nlet ditto = Ditto(identity: identity)\\ntry! ditto.setOfflineOnlyLicenseToken(validLicense);\\n\\n","write-transaction":"ditto.store.write { transaction in\\n    let cars = transaction.scoped(toCollectionNamed: \\"cars\\")\\n    let people = transaction.scoped(toCollectionNamed: \\"people\\")\\n    let docId = \\"abc123\\"\\n    try! people.upsert([\\"_id\\": docId, \\"name\\": \\"Susan\\"])\\n    try! cars.upsert([\\"make\\": \\"Ford\\", \\"color\\": \\"red\\", \\"owner\\": docId])\\n    try! cars.upsert([\\"make\\": \\"Toyota\\", \\"color\\": \\"black\\", \\"owner\\": docId])\\n    people.findByID(docId).evict()\\n}\\n\\n","online-playground":"let ditto = Ditto(identity: DittoIdentity.onlinePlayground(\\n    // Replace the all-zero app ID with your own app ID\\n    appID: \\"00000000-0000-4000-0000-000000000000\\",\\n    token: \\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"\\n))\\ntry! ditto.startSync()\\n\\n","offline-playground":"var ditto = Ditto(identity: DittoIdentity.offlinePlayground(\\n    // Replace the all-zero app ID with your own app ID\\n    appID: \\"00000000-0000-4000-0000-000000000000\\"\\n))\\ntry! ditto.setOfflineOnlyLicenseToken(validLicense);\\ntry! ditto.startSync()\\n\\n","datamodel":"let carsCollection = ditto.store[\\"cars\\"]\\n// or\\nlet carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","attachment":"let collection = ditto.store[\\"foo\\"]\\n\\nlet myImageURL = bundle.url(forResource: \\"image\\", withExtension: \\"png\\")!\\n\\nlet metadata = [\\"name\\": \\"my_image.png\\"]\\nlet attachment = collection.newAttachment(\\n    path: myImageURL.path,\\n    metadata: metadata\\n)!\\n\\nlet docID = try! collection.upsert([\\"some\\": \\"string\\", \\"my_attachment\\": attachment])\\n\\n// Later, find the document and the fetch the attachment\\n\\nlet doc = collection.findByID(docID).exec()\\nlet attachmentToken = doc![\\"my_attachment\\"].attachmentToken!\\n\\nlet fetcher = collection.fetchAttachment(token: attachmentToken) { status in\\n    switch status {\\n    case .completed(let fetchedAttachment):\\n        // Do something with attachment\\n        break\\n    default:\\n        print(\\"Unable to fetch attachment\\")\\n        break\\n    }\\n}\\n\\n","upsert-default-data":"let docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Susan\\",\\n    \\"age\\": 31\\n], writeStrategy: .insertDefaultIfAbsent)\\n\\n","upsert-composite-primary-key":"let docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"_id\\": [ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ],\\n    \\"name\\": \\"Susan\\",\\n    \\"age\\": 31\\n])\\nprint(docID) // \\"[ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ]\\"\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\ntry! ditto.store[\\"foo\\"].upsert([\\n    \\"boolean\\": true,\\n    \\"string\\": \\"Hello World\\",\\n    \\"number\\": 10,\\n    \\"map\\": [\\"key\\": \\"value\\"],\\n    \\"array\\": [1,2,3],\\n    \\"null\\": nil\\n])\\n\\n","counter":"let docId = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Frank\\",\\n    \\"ownedCars\\": 0 // here 0 is a number\\n])\\n\\nditto.store[\\"people\\"].findByID(docId).update({ mutableDoc in\\n    mutableDoc?[\\"ownedCars\\"].set(DittoCounter())\\n    mutableDoc?[\\"ownedCars\\"].counter?.increment(by: 1)\\n})\\n\\n","update":"let docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Frank\\",\\n    \\"age\\": 31,\\n    \\"ownedCars\\": 0\\n])\\n\\nditto.store[\\"people\\"].findByID(docID).update { mutableDoc in\\n    mutableDoc?[\\"age\\"] = 32\\n    mutableDoc?[\\"ownedCars\\"].set(DittoCounter())\\n    mutableDoc?[\\"ownedCars\\"].counter?.increment(by: 1)\\n}\\n\\n","upsert":"// upsert JSON-compatible data into Ditto\\nlet docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"name\\": \\"Susan\\",\\n    \\"age\\": 31\\n])\\n\\n","upsert-id":"// upsert JSON-compatible data into Ditto\\nlet docID = try! ditto.store[\\"people\\"].upsert([\\n    \\"_id\\": \\"abc123\\",\\n    \\"name\\": \\"Susan\\",\\n    \\"age\\": 31\\n])\\n\\n","query-basic":"let collection = ditto.store[\\"people\\"]\\n    .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"let documents = ditto.store[\\"users\\"].find(\\"name == $args.name && age <= $args.age\\", args: [\\n    \\"age\\": 32,\\n    \\"name\\": \\"Max\\"\\n]).exec()\\n\\n","query-sort":"let sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .exec()\\n\\n","query-limit":"let sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfunc userDidInsertCar() {\\n    _ = try! ditto.store.collection(\\"cars\\").upsert([\\n        \\"model\\": \\"Ford\\",\\n        \\"color\\": \\"black\\"\\n    ])\\n}\\n\\n// Register live query to update UI\\nlet liveQuery = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n    .observeLocal { cars, event in\\n        // do something\\n    }\\n\\n","sync-observe":"// Register live query to update UI\\nlet example = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n   .observe { cars, event in\\n     // do something\\n}\\n\\n","subscribe":"// Register live query to update UI\\nlet subscription = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\").subscribe()\\n\\n","network-remote-ditto":"let config = DittoTransportConfig()\\n// Connect explicitly to a remote devices\\nconfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\"\\nlet observer = ditto.observePeersV2 { json in\\n    let peers = DittoPeerV2Parser.parseJson(json: json)!\\n    if !peers.isEmpty {\\n        // render peers\\n    }\\n}\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-listen":"let config = DittoTransportConfig()\\n\\n// Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-multiple-transports":"var config = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\nconfig.enableAllPeerToPeer()\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nlet ditto = Ditto(identity: DittoIdentity.onlinePlayground(appID: \\"00000000-0000-4000-0000-000000000000\\", token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.delegate = self\\ntry! ditto.startSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\nextension ViewController: DittoDelegate {\\n   func transportConditionDidChange(transportID: Int64, condition: TransportCondition) {\\n       if condition == .BleDisabled {\\n           print(\\"BLE disabled\\")\\n       } else if condition == .NoBleCentralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       } else if condition == .NoBlePeripheralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       }\\n   }\\n\\n\\n","network-query-overlap-group":"// The passenger only observes orders that they created\\npassenger.store.collection(\\"orders\\").find(\\"user_id==abc123\\").observe { docs, event in\\n    // render passenger orders in a list UI\\n}\\n\\n// Crew member devices observe all orders that everyone created\\ncrewA.store.collection(\\"orders\\").findAll().observe { docs, event in\\n    // render all orders in a list UI\\n}\\ncrewB.store.collection(\\"orders\\").findAll().observe { docs, event in\\n    // render all orders in a list UI\\n}\\n\\n// Set up our query overlap group and priorities such that the crew members\\n// will construct multihop connections with each other.\\nDittoExperimental.setQueryOverlapGroup(queryOverlapGroup: 2, ditto: crewA)\\nDittoExperimental.setQueryOverlapGroup(queryOverlapGroup: 2, ditto: crewB)\\n\\n// Query overlap groups should be set before startSync\\ntry! crewA.startSync()\\ntry! crewB.startSync()\\ntry! passenger.startSync()\\n\\n","network-set-priority":"DittoExperimental.setPriority(DittoConnectionPriority.high, forQueryOverlapGroup: 2, ditto: crewA)\\nDittoExperimental.setPriority(DittoConnectionPriority.high, forQueryOverlapGroup: 2, ditto: crewB)\\n\\n","evict":"collection.find(\\"owner == \'Bob\'\\").evict()\\n\\n","remove-query":"collection.find(\\"owner == \'Bob\'\\").remove()\\n\\n","remove-id":"collection.findByID(docID).remove()\\n\\n","sync-basic":"try! ditto.startSync()\\n\\n"},"cpp":{"sync-observe-local":"// --- Register live query to update UI\\nstd::shared_ptr<LiveQuery> query =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe_local([&](std::vector<Document> docs, LiveQueryEvent event) {\\n\\n        });\\n\\n","datamodel":"Collection cars_collection = ditto.get_store().collection(\\"cars\\");\\n\\n","upsert-id":"json person = json({{\\"_id\\", \\"123abc\\"}, {\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert":"json person = json({{\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert-composite-primary-key":"json content = json({{\\"_id\\", {{\\"userId\\", \\"456abc\\"}, {\\"workId\\", 789}}},\\n                     {\\"name\\", \\"Susan\\"},\\n                     {\\"age\\", 31}});\\nDocumentId doc_ID = ditto.get_store().collection(\\"people\\").upsert(content);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nditto.get_store().collection(\\"foo\\").upsert(json({{\\"boolean\\", true},\\n                                                 {\\"string\\", \\"Hello World\\"},\\n                                                 {\\"number\\", 10},\\n                                                 {\\"map\\", {{\\"key\\", \\"value\\"}}},\\n                                                 {\\"array\\", {1, 2, 3}},\\n                                                 {\\"null\\", NULL}}));\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared\\n// key for every application.\\nconst std::string p256_der_b64 =\\n    \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4\\"\\n    \\"hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlq\\"\\n    \\"nfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDitto ditto = ditto::Ditto(Identity::SharedKey(\\"\\", p256_der_b64), path);\\nditto.set_offline_only_license_token(valid_license);\\n\\n","attachment":"auto attachment_file_path = fs::path(images_path.string() + \\"/image.png\\");\\nstd::map<std::string, std::string> metadata = {{\\"some\\", \\"string\\"}};\\n\\nAttachment attachment =\\n    collection.new_attachment(attachment_file_path.string(), metadata);\\n\\nauto doc_id =\\n    collection.upsert({{\\"some\\", \\"string\\"}, {\\"my_attachment\\", attachment}});\\n\\n// Later, find the document and the fetch the attachment\\nauto doc = collection.find_by_id(doc_id).exec();\\nauto att_token = (*doc)[\\"my_attachment\\"].get_attachment_token();\\n\\nauto fetcher = collection.fetch_attachment(\\n    att_token,\\n    AttachmentFetcherEventHandler{\\n        [&](std::unique_ptr<AttachmentFetchEvent> event) {\\n          switch (event->type) {\\n          case AttachmentFetchEventType::Completed: {\\n            AttachmentFetchEventCompleted *completed_event =\\n                static_cast<AttachmentFetchEventCompleted *>(event.get());\\n            Attachment fetched_attachment = completed_event->attachment;\\n            // Do something with attachment\\n            break;\\n          }\\n          default:\\n            std::cout << \\"Unable to fetch attachment\\" << std::endl;\\n          }\\n        }});\\n\\n","counter":"DocumentId docID = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"ownedCars\\", 0}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(docID).update(\\n    [](MutableDocument &doc) {\\n      doc[\\"ownedCars\\"].set(Counter());\\n      auto counter = doc[\\"ownedCars\\"].get_counter();\\n      counter->increment(1);\\n    });\\n\\n","update":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"age\\", 31}, {\\"ownedCars\\", 0}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(doc_id).update(\\n    [](MutableDocument &doc) {\\n      doc[\\"age\\"].set(32);\\n      doc[\\"ownedCars\\"].set(Counter());\\n      auto counter = doc[\\"ownedCars\\"].get_counter();\\n      counter->increment(1);\\n    });\\n\\n","remove-id":"ditto.get_store().collection(\\"people\\").find_by_id(doc_id).remove();\\n\\n","remove-query":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-default-data":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    content, WriteStrategy::insertDefaultIfAbsent);\\n\\n","query-basic":"std::vector<Document> results =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"json args = json({{\\"age\\", 32}, {\\"name\\", \\"max\\"}});\\nstd::vector<Document> big_c_values =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", args)\\n        .exec();\\n\\n","query-sort":"std::vector<Document> sorted_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .exec();\\n\\n","query-limit":"std::vector<Document> sorted_and_limited_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n  std::cerr << err.what();\\n}\\n\\n","subscribe":"ditto::Subscription subscription =\\n    collection.find(\\"color == \'red\'\\").subscribe();\\n\\n","sync-observe":"std::shared_ptr<LiveQuery> liveQuery =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe([&](std::vector<Document> docs, LiveQueryEvent event) {\\n          // do something\\n        });\\n\\n","online-playground":"Ditto ditto;\\nauto identity =\\n    Identity::OnlinePlayground(\\"00000000-0000-4000-0000-000000000000\\",\\n                               \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\");\\ntry {\\n  ditto = Ditto(identity, dir);\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","offline-playground":"Ditto ditto;\\nauto identity =\\n    Identity::OfflinePlayground(\\"00000000-0000-4000-0000-000000000000\\");\\ntry {\\n  ditto = Ditto(identity, dir);\\n\\n  ditto.set_offline_only_license_token(valid_license);\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","network-remote-ditto":"auto config = ditto::TransportConfig();\\n// Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\n// set the transport config\\nditto.set_transport_config(config);\\n// now you can start ditto\'s sync\\nditto.start_sync();\\n\\n","network-listen":"auto config = ditto::TransportConfig();\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n","network-multiple-transports":"auto config = ditto::TransportConfig();\\n// 1. Enable All Peer to Peer Connections\\nconfig.enable_all_peer_to_peer();\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n"},"http":{"upsert-composite-primary-key":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"_id\\": { \\n            \\"user_id\\": \\"456abc\\",\\n            \\"work_id\\": 789\\n            },\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","upsert":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\"age\\": 31\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","upsert-id":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"_id\\": \\"456abc\\",\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","upsert-datatypes":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"_id\\": \\"456abc\\",\\n          \\"boolean\\": true, \\n          \\"string\\": \\"Hello World\\",\\n          \\"number\\": 10,\\n          \\"map\\": {\\n            \\"key\\": \\"value\\",\\n          },\\n          \\"array\\": [1,2,3],\\n          \\"null\\": null\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","update":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"write\\",\\n    \\"parameters\\": {\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"value\\": {\\n          \\"_id\\": \\"123abc\\",\\n          \\"name\\": \\"Frank\\", \\n          \\"age\\": 32,\\n          \\"friends\\": [\\"Susan\\"],\\n          \\"owned_cars\\": 0\\n        }\\n      }]\\n    }\\n  }\'\\n\\n","query-basic":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"method\\": \\"find\\",\\n    \\"parameters\\": {\\n      \\"collection\\": \\"people\\",\\n      \\"query\\": \\"favoriteBook.title == \'The Great Gatsby\'\\"\\n    }\\n  }\'\\n\\n","query-args":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"method\\": \\"find\\",\\n    \\"parameters\\": {\\n      \\"args\\": {\\n        \\"name\\": \\"max\\",\\n        \\"age\\": 32\\n      },\\n      \\"collection\\": \\"people\\",\\n      \\"query\\": \\"name == $args.name && age <= $args.age\\"\\n    }\\n  }\'\\n\\n","query-limit":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v1/store\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"method\\": \\"find\\",\\n    \\"parameters\\": {\\n      \\"collection\\": \\"people\\",\\n      \\"query\\": \\"color == \'red\'\\",\\n      \\"limit\\": 100\\n    }\\n  }\'\\n\\n","remove-id":"curl -X DELETE \'https://<CLOUD_ENDPOINT>/api/v1/collections/people/documents/<doc_id>\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\n\\n"},"javascript":{"online-playground":"import { init, Ditto } from \\"@dittolive/ditto\\"\\nconst identity: Identity = { type: \'onlinePlayground\', appID: \'00000000-0000-4000-0000-000000000000\', token: \'REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\' }\\nconst ditto = new Ditto(identity, path)\\nditto.startSync()\\n\\n","offline-playground":"const identity: Identity = { type: \'offlinePlayground\', appID: \'00000000-0000-4000-0000-000000000000\' }\\nconst ditto = new Ditto(identity, path)\\nditto.setOfflineOnlyLicenseToken(validLicense)\\nditto.startSync()\\n\\n","datamodel":"const carsCollection = ditto.store.collection(\'cars\')\\n\\n","upsert-id":"const docID = await ditto.store.collection(\'people\').upsert({\\n  _id: \'123abc\',\\n  name: \'Susan\',\\n  age: 31,\\n})\\n\\nconsole.log(docID) // \\"123abc\\"\\n\\n","upsert":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docID) // \\"507f191e810c19729de860ea\\"\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nawait ditto.store.collection(\'people\').upsert({\\n  boolean: true,\\n  string: \'Hello World\',\\n  number: 10,\\n  map: { key: \'value\' },\\n  array: [],\\n  null: null,\\n})\\n\\n","counter":"const frankId = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  ownedCars: 0, // here 0 is a number\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(frankId)\\n  .update((mutableDoc) => {\\n    mutableDoc.at(\'ownedCars\').set(new Counter())\\n    mutableDoc.at(\'ownedCars\').counter.increment(1)\\n  })\\n\\n","upsert-default-data":"const docID = await ditto.store.collection(\'people\').upsert(\\n  {\\n    name: \'Susan\',\\n    age: 31,\\n  },\\n  { writeStrategy: \'insertDefaultIfAbsent\' },\\n)\\n\\n","upsert-composite-primary-key":"const docID = await ditto.store.collection(\'people\').upsert({\\n  _id: { userID: \'456abc\', workID: 789 },\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docID) // \\"{ \\"userID\\": \\"456abc\\", \\"workID\\": 789 }\\"\\n\\n","update":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  age: 31,\\n  ownedCars: 0,\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(docID)\\n  .update((mutableDoc) => {\\n    mutableDoc.at(\'age\').set(32)\\n\\n    mutableDoc.at(\'ownedCars\').set(new Counter())\\n    mutableDoc.at(\'ownedCars\').counter.increment(1)\\n  })\\n\\n","query-basic":"const collection = await ditto.store.collection(\'people\').find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n\\n","remove-id":"await ditto.store.collection(\'people\').findByID(docID).remove()\\n\\n","query-args":"const query = \'name == $args.name && age <= $args.age\'\\nconst documents = await ditto.store.collection(\'people\').find(query, {\\n  age: 32,\\n  name: \'Max\',\\n})\\n\\n","remove-query":"await ditto.store.collection(\'people\').find(\'age <= 32\').remove()\\n\\n","query-sort":"const sortedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\')\\n\\n","query-limit":"const sortedAndLimitedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\').limit(100)\\n\\n","evict":"await ditto.store.collection(\'people\').find(\'age <= 32\').evict()\\n\\n","sync-basic":"try {\\n  ditto.startSync()\\n} catch (err) {\\n  console.error(err)\\n}\\n\\n","sync-observe":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observe((cars, event) => {\\n    // do something\\n  })\\n\\n","subscribe":"const subscription = ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").subscribe()\\n\\n","sync-observe-local":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observeLocal((cars, event) => {\\n    // do something\\n  })\\n\\n","attachment":"const collection = ditto.store.collection(\'foo\')\\n\\nconst myImageBase64 = \'iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEW10NBjBBbqAAAAH0lEQVRoge3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAvg0hAAABmmDh1QAAAABJRU5ErkJggg==\'\\nconst myImageBytes = Uint8Array.from(myImageBase64, (character) => character.charCodeAt(0))\\nconst metadata = { name: \'image.png\' }\\n\\n// On Node, you can also pass a file path (string) instead of image data\\n// and the attachment will be created from that file.\\nconst attachment = await collection.newAttachment(myImageBytes, metadata)\\n\\nconst docID = await collection.upsert({ some: \'string\', my_attachment: attachment })\\n\\n// Later, find the document and then fetch the attachment\\n\\nconst doc = await collection.findByID(docID)\\nconst attachmentToken = doc.at(\'my_attachment\').attachmentToken\\n\\nconst attachmentFetcher = collection.fetchAttachment(attachmentToken, async (attachmentFetchEvent) => {\\n  switch (attachmentFetchEvent.type) {\\n    case \'Completed\':\\n      const fetchedAttachment = attachmentFetchEvent.attachment\\n      // Do something with attachment\\n      break\\n\\n    default:\\n      console.log(\'Unable to fetch attachment\')\\n      break\\n  }\\n})\\n\\n// There is also a more convenient way of fetching the attachment\\n// (AttachmentFetcher implements the `PromiseLike` protocol):\\nconst fetchedAttachment = await collection.fetchAttachment(attachmentToken)\\n// Do something with attachment\\n\\n","network-remote-ditto":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.connect.websocketURLs.push(\'wss://135.1.5.5:12345\')\\nconfig.connect.websocketURLs.push(\'wss://185.1.5.5:12345\')\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n\\n","network-monitor-conditions":"const transportConditionsObserver = ditto.observeTransportConditions((condition, source) => {\\n  if (condition === \'BLEDisabled\') {\\n    console.log(\'BLE disabled\')\\n  } else if (condition === \'NoBLECentralPermission\') {\\n    console.log(\'Permission missing for BLE\')\\n  } else if (condition === \'NoBLEPeripheralPermission\') {\\n    console.log(\'Permissions missing for BLE\')\\n  }\\n})\\n\\n","network-multiple-transports":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\n// 1. Enable All Peer to Peer Connections (not in a browser environment)\\nconfig.setAllPeerToPeerEnabled(true)\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","network-listen":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n"},"csharp":{"sync-basic":"try\\n{\\n    onlineDitto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    // handle exception\\n}\\n\\n","remove-query":"ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Remove();\\n\\n","remove-id":"var wasRemoved = coll.FindById(docID).Remove();\\n\\n","counter":"var counter = new DittoCounter();\\n\\nvar docID = coll.Upsert(new Dictionary<string, object> {\\n    { \\"make\\", \\"Honda\\" }, { \\"mileage\\", counter }\\n});\\n\\n_ = coll.FindById(docID).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"mileage\\"].Counter.Increment(100);\\n});\\n\\n","update":"var content = new Dictionary<string, object>\\n{\\n    { \\"name\\", \\"Bob\\" },\\n    { \\"age\\", 40 },\\n    { \\"ownedCars\\",  new DittoCounter() }\\n};\\n\\nvar docId = Ditto.Store.Collection(\\"people\\").Upsert(content);\\nDitto.Store.Collection(\\"people\\").FindById(docId).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"age\\"].Set(32);\\n    mutableDoc[\\"ownedCars\\"].Counter.Increment(1);\\n});\\n\\n","evict":"Ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Evict();\\n\\n","attachment":"string attachmentImagePath = Path.Combine(Directory.GetCurrentDirectory(), \\"attachment_test.png\\");\\n\\nvar originalBytes = File.ReadAllBytes(attachmentImagePath);\\n\\nvar metadata = new Dictionary<string, string> { { \\"name\\", \\"my_image.png\\" } };\\nvar attachment = coll.NewAttachment(attachmentImagePath, metadata);\\n\\nvar docId = coll.Upsert(new Dictionary<string, object> { { \\"some\\", \\"string\\" }, { \\"my_attachment\\", attachment } });\\n\\nvar doc = coll.FindById(docId).Exec();\\nvar attachmentToken = doc[\\"my_attachment\\"].AttachmentToken;\\nusing var fetcher = coll.FetchAttachment(attachmentToken, ev =>\\n{\\n    switch (ev)\\n    {\\n        case DittoAttachmentFetchEvent.Completed e:\\n            // Do something with attachment\\n            break;\\n        default:\\n            Console.WriteLine(\\"Unable to fetch attachment\\");\\n            break;\\n    }\\n});\\n\\n","upsert-composite-primary-key":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object> {\\n    { \\"_id\\", new Dictionary<string, object> {{ \\"userId\\", \\"456abc\\" }, { \\"workId\\", 789 }} },\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 }\\n};\\nvar docId = ditto.Store.Collection(\\"people\\").Upsert(content);\\n\\n","upsert-default-data":"// Immediately try and insert some new default data\\nvar docId = coll.Upsert(\\n    new Dictionary<string, object> { { \\"name\\", \\"Susan\\" } },\\n    DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","datamodel":"var coll = ditto.Store.Collection(\\"people\\");\\n\\n","upsert":"var docId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 },\\n    }\\n);\\n\\n","upsert-id":"var returnedId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n        { \\"_id\\", \\"123abc\\" },\\n        { \\"name\\", \\"Joe\\" },\\n        { \\"age\\", 32 },\\n        { \\"isOnline\\", true }\\n    }\\n);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object>\\n{\\n    { \\"boolean\\", true },\\n    { \\"string\\", \\"Hello World\\" },\\n    { \\"number\\", 10 },\\n    { \\"map\\", new Dictionary<string, string>{{ \\"key\\", \\"value\\"}} },\\n    { \\"array\\", new[] {1, 2, 3} },\\n    { \\"null\\", null }\\n};\\nDitto.Store.Collection(\\"foo\\").Upsert(content);\\n\\n","online-playground":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OnlinePlayground(\\"00000000-0000-4000-0000-000000000000\\", \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"), path);\\n    ditto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","offline-playground":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OfflinePlayground(\\"00000000-0000-4000-0000-000000000000\\"), path);\\n    ditto.StartSync();\\n    ditto.SetOfflineOnlyLicenseToken(validLicense);\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nstring p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nvar identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64);\\nvar ditto = new Ditto(identity);\\ntry\\n{\\n    ditto.SetOfflineOnlyLicenseToken(validLicense);\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","query-basic":"var results = ditto.Store.Collection(\\"people\\")\\n    .Find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .Exec();\\n\\n","query-args":"var docs = ditto.Store\\n    .Collection(\\"users\\")\\n    .Find(\\n        \\"name == $args.name && age <= $args.age\\",\\n        new Dictionary<string, object> { { \\"name\\", \\"max\\" }, { \\"age\\", 32 } })\\n    .Exec();\\n\\n","query-sort":"var sortedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Exec();\\n\\n","query-limit":"var sortedAndLimitedRedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Limit(100).Exec();\\n\\n","subscribe":"// --- Register live query to update UI\\nvar subscription = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .Subscribe();\\n\\n","sync-observe":"// --- Register live query to update UI\\nvar liveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .Observe((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\").ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","sync-observe-local":"// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","network-remote-ditto":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n// Connect explicitly to a remote device on\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\n// you can add as many TcpServers as you would like.\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:4567\\");\\n// set the transport config\\nDitto.TransportConfig = transportConfig;\\n// now you can start ditto\'s sync\\nDitto.StartSync();\\n\\n","network-listen":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\ntransportConfig.Listen.Tcp = new DittoTcpListenConfig();\\n// By default Listen.Tcp.Enabled is false, be sure to set it to true.\\ntransportConfig.Listen.Tcp.Enabled = true;\\n// if you want to listen on localhost, most likely you will use 0.0.0.0\\n// do not use \\"localhost\\" as a string\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\n// specify your port.\\ntransportConfig.Listen.Tcp.Port = 4000;\\nDitto.TransportConfig = transportConfig;\\n\\n// now you can call `ditto.StartSync()`\\nDitto.StartSync();\\n\\n","network-multiple-transports":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n\\n// 1. Enable Local Area Network Connections\\ntransportConfig.EnableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.Listen.Tcp.Enabled = true;\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\ntransportConfig.Listen.Tcp.Port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:12345\\");\\n\\nditto.TransportConfig = transportConfig;\\n\\nditto.StartSync();\\n\\n","network-set-priority":"DittoExperimental.SetPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2, crewB);\\nDittoExperimental.SetPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2, crewA);\\n\\n"},"kotlin":{"attachment":"val testContext = InstrumentationRegistry.getInstrumentation().context\\nval attachmentStream = testContext.assets.open(\\"attachment_test.png\\")\\n\\nval bitmapStream = testContext.assets.open(\\"attachment_test.png\\")\\nval attachmentBitmap = BitmapFactory.decodeStream(bitmapStream)\\nbitmapStream.close()\\n\\nval metadata = mapOf(\\"name\\" to \\"my_image.png\\")\\nval attachment = coll.newAttachment(attachmentStream, metadata)\\n\\nval docID = coll.upsert(mapOf(\\"some\\" to \\"string\\", \\"my_attachment\\" to attachment))\\nval doc = coll.findByID(docID).exec()\\nval attachmentToken = doc!![\\"my_attachment\\"].attachmentToken\\n\\nval fetcher = coll.fetchAttachment(attachmentToken!!) {\\n    when (it) {\\n        is Completed -> {\\n            val attBitmap: Bitmap = BitmapFactory.decodeStream(it.attachment.getInputStream())\\n        }\\n        is Progress -> {}\\n    }\\n}\\n\\n","datamodel":"val carsCollection = ditto.store[\\"cars\\"]\\n// or\\nval carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","upsert-id":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to \\"123abc\\",\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert":"val docID = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-composite-primary-key":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to mapOf( \\"userId\\" to \\"456abc\\", \\"workId\\" to 789),\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-datatypes":"ditto.store[\\"foo\\"].upsert(mapOf(\\n    \\"boolean\\" to true,\\n    \\"string\\" to \\"Hello World\\",\\n    \\"number\\" to 10,\\n    \\"map\\" to mapOf(\\"key\\" to \\"value\\"),\\n    \\"array\\" to listOf(1,2,3),\\n    \\"null\\" to null\\n))\\n\\n","write-transaction":"val results = ditto.store.write { transaction ->\\n    val cars = transaction.scoped(\\"cars\\")\\n    val people = transaction.scoped(\\"people\\")\\n    val docId = \\"abc123\\"\\n    people.upsert(mapOf(\\"_id\\" to docId, \\"name\\" to \\"Susan\\"))\\n    cars.upsert(mapOf(\\"make\\" to \\"Hyundai\\", \\"color\\" to \\"red\\", \\"owner\\" to docId))\\n    cars.upsert(mapOf(\\"make\\" to \\"Jeep\\", \\"color\\" to \\"pink\\", \\"owner\\" to docId))\\n    people.findByID(DittoDocumentID(docId)).evict()\\n}\\n\\n","counter":"val docID = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"ownedCars\\" to DittoCounter()\\n))\\n\\nditto.store.collection(\\"people\\").findByID(docID).update { mutableDoc ->\\n    mutableDoc!![\\"ownedCars\\"].counter!!.increment(amount = 1.0)\\n}\\n\\n","counter-upsert":"val frankId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"age\\" to 31,\\n    \\"ownedCars\\" to DittoCounter()\\n))\\n\\n","update":"ditto.store.collection(\\"people\\").findByID(frankId).update { mutableDoc ->\\n    mutableDoc?.let {\\n        it[\\"age\\"].set(32)\\n        it[\\"ownedCars\\"].counter!!.increment(amount = 1.0)\\n    }\\n}\\n\\n","evict":"ditto.store[\\"people\\"].find(\\"age <= 32\\").evict()\\n\\n","upsert-default-data":"val docId = ditto.store.collection(\\"people\\").upsert(mapOf(\\n    \\"name\\" to \\"Susan\\",\\n    \\"age\\" to 31\\n), DittoWriteStrategy.InsertDefaultIfAbsent)\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\"\\nditto.startSync()\\nditto.observePeersV2 { peers ->\\n    // render peer list\\n}\\n\\n","query-basic":"val results = ditto.store.collection(\\"people\\")\\n    .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"val foundDocs = ditto.store.collection(\\"people\\")\\n    .find(\\"name == \\\\$args.name && age <= \\\\$args.age\\", mapOf(\\"name\\" to \\"max\\", \\"age\\" to 32))\\n\\n","query-sort":"val sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .exec()\\n\\n","query-limit":"val sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-basic":"try {\\n    ditto.startSync()\\n}\\ncatch (e: DittoError) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- DittoRegister live query to update UI\\nval liveQuery = ditto.store.collection(\\"cars\\")\\n    .findAll()\\n    .observe { docs, event ->\\n        // Do something...\\n    }\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfun userDidInsertCar() {\\n    ditto.store.collection(\\"cars\\").upsert(mapOf(\\n        \\"model\\" to \\"Ford\\",\\n        \\"color\\" to \\"black\\"\\n    ))\\n}\\n\\n// --- DittoRegister live query to update UI\\nval observeLocalQuery = ditto.store.collection(\\"cars\\")\\n    .findAll()\\n    .observeLocal { docs, event ->\\n    // Do something...\\n}\\n\\n","subscribe":"// --- DittoRegister live query to update UI\\nval subscription = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .subscribe()\\n\\n","online-playground":"try {\\n    val androidDependencies = DefaultAndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OnlinePlayground(androidDependencies, appID = \\"00000000-0000-4000-0000-000000000000\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\")\\n    val ditto = Ditto(androidDependencies, identity)\\n    ditto.startSync()\\n} catch(e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","offline-playground":"try {\\n    val androidDependencies = AndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OfflinePlayground(androidDependencies, appID = \\"00000000-0000-4000-0000-000000000000\\")\\n    val ditto = Ditto(androidDependencies, identity)\\n    ditto.setOfflineOnlyLicenseToken(validLicense)\\n    ditto.startSync()\\n} catch(e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nval p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\nval androidDependencies = DefaultAndroidDittoDependencies(context)\\nval identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64, null)\\nval ditto = Ditto(androidDependencies, identity)\\nditto.setOfflineOnlyLicenseToken(validLicense)\\n\\n","network-remote-ditto":"val transportConfig = DittoTransportConfig()\\n\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.startSync()\\n\\n","network-listen":"val transportConfig = DittoTransportConfig()\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\nditto.startSync()\\n\\n","network-multiple-transports":"val transportConfig = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\ntransportConfig.enableAllPeerToPeer()\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.listen.tcp.enabled = true\\ntransportConfig.listen.http.enabled = false\\ntransportConfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\ntransportConfig.listen.tcp.port = 4000\\n// 3. Connect explicitly to remote devices\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.startSync()\\n\\n","network-monitor-conditions":"// ... Setting up inside an Activity\\nval androidDependencies = DefaultAndroidDittoDependencies(applicationContext)\\nval ditto = Ditto(androidDependencies, DittoIdentity.OnlinePlayground(androidDependencies, appID = \\"REPLACE_WITH_APP_ID\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.callback = this\\nditto.startSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\n\\nclass MainActivity : AppCompatActivity(), DittoCallback {\\n\\n    override fun transportConditionDidChange(transportId: Long, condition: TransportCondition) {\\n        var toastText: String? = null\\n        if (condition == TransportCondition.TRANSPORT_CONDITION_BLE_DISABLED) {\\n            toastText = \\"BLE disabled\\"\\n        } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION) {\\n            toastText = \\"Permission missing for BLE\\"\\n        } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION) {\\n            toastText = \\"Permission missing for BLE\\"\\n        }\\n        toastText?.let {\\n            Handler(mainLooper).post {\\n                Toast.makeText(this, it, Toast.LENGTH_LONG).show()\\n            }\\n        }\\n    }\\n}\\n\\n","network-query-overlap-group":"// The passenger only observes orders that they created\\npassenger.store.collection(\\"orders\\").find(\\"user_id==abc123\\").observe({ docs, event ->\\n    // render passenger orders in a list UI\\n})\\n\\n// Crew member devices observe all orders that everyone created\\ncrewA.store.collection(\\"orders\\").findAll().observe({ docs, event ->\\n    // render all orders in a list UI\\n})\\ncrewB.store.collection(\\"orders\\").findAll().observe({ docs, event ->\\n    // render all orders in a list UI\\n})\\n\\nDittoExperimental.setQueryOverlapGroup(2u, crewA)\\nDittoExperimental.setQueryOverlapGroup(2u, crewB)\\n\\ncrewA.startSync()\\ncrewB.startSync()\\npassenger.startSync()\\n\\n","network-set-priority":"DittoExperimental.setPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2u, crewA)\\nDittoExperimental.setPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2u, crewB)\\n\\n","remove-id":"coll.findByID(docID).remove()\\n\\n","remove-query":"val removedDocIDs = coll.find(\\"make == \'Honda\'\\").remove()\\n\\n"},"java":{"attachment":"String attachmentPath = tempFile.getPath();\\nMap<String, String> metadata = new HashMap<>();\\nmetadata.put(\\"name\\", \\"my_image.png\\");\\nDittoAttachment attachment = coll.newAttachment(attachmentPath, metadata);\\ntempFile.delete();\\n\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"some\\", \\"string\\");\\ncontent.put(\\"my_attachment\\", attachment);\\nDittoDocumentID docID = coll.upsert(content);\\n\\nDittoDocument doc = coll.findByID(docID).exec();\\nDittoAttachmentToken attachmentToken = doc.get(\\"my_attachment\\").getAttachmentToken();\\n\\nDittoAttachmentFetcher fetcher = coll.fetchAttachment(attachmentToken, event -> {\\n    if (event.getType() == DittoAttachmentFetchEventType.Completed) {\\n        DittoAttachment att = event.asCompleted().getAttachment();\\n        BufferedImage attachmentImage;\\n        try {\\n            attachmentImage = ImageIO.read(att.getInputStream());\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n    } else if (event.getType() == DittoAttachmentFetchEventType.Progress) {\\n        // do nothing - wait for `Completed` or `Deleted`\\n    } else {\\n    }\\n});\\n\\n\\n","datamodel":"DittoCollection carsCollection = ditto.store.collection(\\"cars\\");\\n\\n","upsert-id":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"_id\\", \\"123abc\\");\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentID docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 123abc\\n\\n","upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentID docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 507f191e810c19729de860ea\\n\\n","upsert-composite-primary-key":"Map<String, Object> _id = new HashMap<>();\\n_id.put(\\"userId\\", \\"456abc\\");\\n_id.put(\\"workId\\", 789);\\n\\nMap<String, Object> value = new HashMap<>();\\nvalue.put(\\"_id\\", _id);\\nvalue.put(\\"name\\", \\"Susan\\");\\nvalue.put(\\"age\\", 31);\\nDittoDocumentID docID = ditto.store.collection(\\"people\\").upsert(value);\\n// docId=> \\"_id.put(\\"userId\\", \\"456abc\\"); _id.put(\\"workId\\", 789);\\"\\n\\n","remove-id":"ditto.store.collection(\\"people\\").findByID(docId).remove();\\n\\n","remove-query":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"boolean\\", true);\\ncontent.put(\\"string\\", \\"Hello World\\");\\ncontent.put(\\"number\\", 10);\\nMap<String, String> innerMap = new HashMap<>();\\ninnerMap.put(\\"key\\", \\"value\\");\\ncontent.put(\\"map\\", innerMap);\\ncontent.put(\\"array\\", Arrays.asList(1, 2, 3));\\ncontent.put(\\"null\\", null);\\nditto.store.collection(\\"foo\\").upsert(content);\\n\\n","counter":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"ownedCars\\", new DittoCounter());\\nDittoDocumentID docID = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findByID(docID).update(mutDoc -> {\\n    assertThat(mutDoc).isNotNull();\\n    DittoMutableCounter counter = mutDoc.get(\\"ownedCars\\").getCounter();\\n    assertThat(counter).isNotNull();\\n    counter.increment(1);\\n});\\n\\n","counter-upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"age\\", 31);\\ncontent.put(\\"ownedCars\\", new DittoCounter());\\nDittoDocumentID docId = ditto.store.collection(\\"people\\").upsert(content);\\n\\n","update":"ditto.store.collection(\\"people\\").findByID(docId).update(doc -> {\\n    try {\\n        doc.get(\\"age\\").set(32);\\n        doc.get(\\"ownedCars\\").getCounter().increment(1);\\n    } catch (DittoError err) {\\n        // Do something with error\\n    }\\n});\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\";\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\nditto.observePeersV2(peers -> {\\n    // render peers\\n});\\n\\n","upsert-default-data":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentID docId = ditto.store\\n        .collection(\\"people\\")\\n        .upsert(content, DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","query-basic":"List<DittoDocument> results = ditto.store.collection(\\"people\\")\\n        .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"Map<String, Object> queryArgs = new HashMap<>();\\nqueryArgs.put(\\"name\\", \\"max\\");\\nqueryArgs.put(\\"age\\", 32);\\n\\nList<DittoDocument> foundDocs = ditto.store.collection(\\"users\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", queryArgs)\\n        .exec();\\n\\n","query-sort":"List<DittoDocument> sortedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .exec();\\n\\n","query-limit":"List<DittoDocument> sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- Register live query to update UI\\nDittoLiveQuery liveQuery = ditto.store.collection(\\"cars\\")\\n        .findAll()\\n        .observe((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","subscribe":"// --- Register live query to update UI\\nDittoSubscription subscription = ditto.store.collection(\\"cars\\")\\n        .findAll()\\n        .subscribe();\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"model\\", \\"Ford\\");\\ncontent.put(\\"color\\", \\"black\\");\\nditto.store.collection(\\"cars\\").upsert(content);\\n\\n// --- Register live query to update UI\\nDittoLiveQuery liveQueryLocal = ditto.store.collection(\\"cars\\")\\n        .findAll()\\n        .observeLocal((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nString p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.SharedKey(androidDependencies, \\"app\\", p256DerB64);\\nDitto ditto = new Ditto(androidDependencies, identity);\\ntry {\\n    ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","online-playground":"DittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.OnlinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\", \\"YOUR_PLAYGROUND_TOKEN_HERE\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","offline-playground":"DittoIdentity identity = new DittoIdentity.OfflinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\ntry {\\n    ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch(DittoError e) {\\n    //handle error\\n}\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","network-remote-ditto":"DittoTransportConfig config = new DittoTransportConfig();\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-listen":"DittoTransportConfig config = new DittoTransportConfig();\\nconfig.enableAllPeerToPeer();\\n\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-multiple-transports":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n// 1. Enable Peer to Peer Connections\\nconfig.enableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n// 3. Connect explicitly to remote devices\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-monitor-conditions":"// Setting up inside an Activity\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(getApplicationContext());\\nDitto ditto = new Ditto(androidDependencies, new DittoIdentity.OnlinePlayground(androidDependenciesOne, \\"REPLACE_WITH_APP_ID\\"));\\nditto.callback = this;\\nditto.startSync();\\n\\n// Now you can observe real time changes to the transport conditions:\\npublic class MainActivity extends AppCompatActivity implements DittoCallback {\\n    @Override\\n    public void transportConditionDidChange(@NotNull DittoTransportCondition condition, @NotNull DittoConditionSource transportId) {\\n        String toastText = null;\\n        if (condition == DittoTransportCondition.BleDisabled) {\\n            toastText = \\"BLE disabled\\";\\n        } else if (condition == DittoTransportCondition.NoBleCentralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        } else if (condition == DittoTransportCondition.NoBlePeripheralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        }\\n\\n        if (toastText != null) {\\n            String finalToastText = toastText;\\n            runOnUiThread(new Runnable() {\\n                @Override\\n                public void run() {\\n                    Toast.makeText(MainActivity.this, finalToastText, Toast.LENGTH_LONG).show();\\n                }\\n            });\\n        }\\n    }\\n}\\n\\n"}}'),a=e(99013),c=e(49366),s=e(30547);function l(n){var t,e=n.name,r=n.language,c=n.label,s=i[r];if(s){var l=s[e];l&&(t=l)}return t?o.createElement(a.Z,{className:r},t.trim().replace("00000000-0000-4000-0000-000000000000","REPLACE_ME_WITH_YOUR_APP_ID")):(console.error("no snippet for "+e+" in language="+r),o.createElement("div",null,"Not supported by ",c,"."))}function d(n){n.children;var t=n.name,e=(0,r.Z)(),i=e.tabGroupChoices,a=(e.setTabGroupChoices,i.platform),d=function(n){var t=[{label:"JavaScript",value:"javascript"},{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"},{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"},{label:"C#",value:"csharp"},{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"http"}];switch(n){case"android":t=[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}];break;case"ios":t=[{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"}];break;case"raspberrypi":t=[{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"http"}];case void 0:break;default:t=t.filter((function(t){return t.value===n}))}return t}(a),p=d[0];return o.createElement(c.Z,{platform:a,groupId:"programming-language",defaultValue:p?p.value:"swift",values:d},d.map((function(n){return o.createElement(s.Z,{key:n.value+"-"+t,value:n.value},o.createElement(l,{name:t,language:n.value,label:n.label}))})))}},99013:function(n,t,e){e.d(t,{Z:function(){return C}});var o=e(87462),r=e(67294),i=e(86010),a=e(23746),c=e(10195),s=e(87594),l=e.n(s),d=e(95999),p=e(67804),u=e(71418),m="codeBlockContainer_2gih",g="codeBlockContent_3z4W",y="codeBlockTitle_1Kb7",f="codeBlock_6upA",D="copyButton_2e3i",h="codeBlockLines_xlV7",v=e(32822),b=/{([\d,-]+)}/,I=["js","jsBlock","jsx","python","html"],A={js:{start:"\\/\\/",end:""},jsBlock:{start:"\\/\\*",end:"\\*\\/"},jsx:{start:"\\{\\s*\\/\\*",end:"\\*\\/\\s*\\}"},python:{start:"#",end:""},html:{start:"\x3c!--",end:"--\x3e"}},_=["highlight-next-line","highlight-start","highlight-end"],w=function(n){void 0===n&&(n=I);var t=n.map((function(n){var t=A[n],e=t.start,o=t.end;return"(?:"+e+"\\s*("+_.join("|")+")\\s*"+o+")"})).join("|");return new RegExp("^\\s*(?:"+t+")\\s*$")};function C(n){var t=n.children,e=n.className,s=n.metastring,I=n.title,A=(0,v.LU)().prism,_=(0,r.useState)(!1),C=_[0],T=_[1],S=(0,r.useState)(!1),k=S[0],E=S[1];(0,r.useEffect)((function(){E(!0)}),[]);var L=(0,v.bc)(s)||I,O=(0,r.useRef)(null),N=[],P=Array.isArray(t)?t.join(""):t;if(s&&b.test(s)){var B=s.match(b)[1];N=l()(B).filter((function(n){return n>0}))}var x=null==e?void 0:e.replace(/language-/,"");!x&&A.defaultLanguage&&(x=A.defaultLanguage);var j=P.replace(/\n$/,"");if(0===N.length&&void 0!==x){for(var G,R="",U=function(n){switch(n){case"js":case"javascript":case"ts":case"typescript":return w(["js","jsBlock"]);case"jsx":case"tsx":return w(["js","jsBlock","jsx"]);case"html":return w(["js","jsBlock","html"]);case"python":case"py":return w(["python"]);default:return w()}}(x),q=P.replace(/\n$/,"").split("\n"),M=0;M<q.length;){var H=M+1,Q=q[M].match(U);if(null!==Q){switch(Q.slice(1).reduce((function(n,t){return n||t}),void 0)){case"highlight-next-line":R+=H+",";break;case"highlight-start":G=H;break;case"highlight-end":R+=G+"-"+(H-1)+","}q.splice(M,1)}else M+=1}N=l()(R),j=q.join("\n")}var F=function(){(0,c.Z)(j),T(!0),setTimeout((function(){return T(!1)}),2e3)};return r.createElement(a.ZP,(0,o.Z)({},a.lG,{key:String(k),theme:u.Z,code:j,language:x}),(function(n){var t=n.className,e=n.style,a=n.tokens,c=n.getLineProps,s=n.getTokenProps;return r.createElement("div",{className:m},L&&r.createElement("div",{style:e,className:y},L),r.createElement("div",{className:(0,i.Z)(g,x)},r.createElement("pre",{tabIndex:0,className:(0,i.Z)(t,f,"thin-scrollbar")},r.createElement("code",{className:h},a.map((function(n,t){1===n.length&&""===n[0].content&&(n[0].content="\n");var e=c({line:n,key:t}),a=N.includes(t+1);N.includes(t+1)&&(e.className+="bg-gray-800 docusaurus-highlight-code-line");var l=(0,i.Z)(e.className,a&&"bg-gray-700");return r.createElement("span",(0,o.Z)({key:t},e,{className:l}),n.map((function(n,t){var e=Object.assign({},s({token:n,key:t})),a=e.className;return a.includes("inserted-sign")&&(a=(0,i.Z)(a,"bg-green-900")),a.includes("deleted-sign")&&(a=(0,i.Z)(a,"bg-red-900")),r.createElement("span",(0,o.Z)({key:t},e,{className:a}))})))})))),r.createElement("button",{ref:O,type:"button","aria-label":(0,d.I)({id:"theme.CodeBlock.copyButtonAriaLabel",message:"Copy code to clipboard",description:"The ARIA label for copy code blocks button"}),className:(0,i.Z)(D,"clean-btn",C?"bg-green-500":""),onClick:F},C?r.createElement("div",null,r.createElement(p.C2q,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copied")):r.createElement("div",null,r.createElement(p.Kmg,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copy")))))}))}},30547:function(n,t,e){var o=e(67294);t.Z=function(n){var t=n.children,e=n.hidden,r=n.className;return o.createElement("div",{role:"tabpanel",hidden:e,className:r},t)}},49366:function(n,t,e){var o=e(67294),r=e(80944),i=e(86010);t.Z=function(n){var t,e=n.lazy,a=n.platform,c=(n.block,n.defaultValue),s=n.values,l=n.groupId,d=(n.className,o.Children.toArray(n.children)),p=null!=s?s:d.map((function(n){return{value:n.props.value,label:n.props.label}})),u=null!=c?c:null==(t=d.find((function(n){return n.props.default})))?void 0:t.props.value,m=(0,r.Z)(),g=m.tabGroupChoices,y=m.setTabGroupChoices,f=(0,o.useState)(u),D=f[0],h=f[1];(0,o.useEffect)((function(){if(null!=l){var n=g[l];null!=n&&n!==D&&(p.some((function(t){return t.value===n}))?h(n):h(u))}}),[a,g[l]]);var v=function(n){h(n),null!=l&&y(l,n)},b=p.length>1;return o.createElement("div",{className:"tabs-container"},b&&o.createElement(o.Fragment,null,o.createElement("div",{className:"sm:hidden"},o.createElement("label",{htmlFor:"tabs",className:"sr-only"},"Select a tab"),o.createElement("select",{id:"tabs",name:"tabs",value:D,onChange:function(n){return v(n.currentTarget.value)},className:"block w-full focus:ring-blue-500 focus:border-blue-500 border-gray-300 rounded-md"},p.map((function(n){var t=n.value,e=n.label;return o.createElement("option",{value:t,key:t},null!=e?e:t)})))),o.createElement("div",{className:"hidden sm:block"},o.createElement("nav",{className:"flex space-x-4","aria-label":"Tabs"},p.map((function(n){var t=n.value,e=n.label;return o.createElement("button",{key:t,onClick:function(){return v(t)},className:(0,i.Z)(D===t?"bg-blue-100 text-blue-700":"text-gray-500 hover:text-gray-700","px-3 py-2 font-medium text-sm rounded-md"),"aria-current":D===t?"page":void 0},null!=e?e:t)}))))),e?(0,o.cloneElement)(d.filter((function(n){return n.props.value===D}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},d.map((function(n,t){return(0,o.cloneElement)(n,{key:t,hidden:n.props.value!==D})}))))}},19167:function(n,t,e){e.r(t),e.d(t,{contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return p}});var o=e(87462),r=e(63366),i=(e(67294),e(3905)),a=(e(49366),e(30547),e(36438)),c=["components"],s={title:"Attachment",sidebar_position:4},l=void 0,d={unversionedId:"datamodel/attachment",id:"datamodel/attachment",isDocsHomePage:!1,title:"Attachment",description:"If you have a large amount of binary data, or perhaps just a large file, that",source:"@site/docs/common/datamodel/attachment.mdx",sourceDirName:"datamodel",slug:"/datamodel/attachment",permalink:"/common/datamodel/attachment",editUrl:"https://github.com/getditto/docs/edit/main/docs/common/datamodel/attachment.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Attachment",sidebar_position:4},sidebar:"defaultSidebar",previous:{title:"Map",permalink:"/common/datamodel/map"},next:{title:"Schemas",permalink:"/common/datamodel/schemas"}},p=[],u={toc:p};function m(n){var t=n.components,e=(0,r.Z)(n,c);return(0,i.kt)("wrapper",(0,o.Z)({},u,e,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If you have a large amount of binary data, or perhaps just a large file, that\nyou want to sync between devices then instead of inserting this into a document\nas bytes you should make use of the attachments feature."),(0,i.kt)("p",null,"Attachments do not get synced between devices by default, even if they are part\nof a document that is being synced between devices. This is because they could\nbe very large files that a given device doesn't need. Instead an attachment must\nbe explicitly fetched using an attachment token that will be present in the\ndocument that the attachment is linked to."),(0,i.kt)(a.Z,{name:"attachment",mdxType:"SnippetGroup"}))}m.isMDXComponent=!0}}]);